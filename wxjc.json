{"title": "微信小程序开发需要注意的一些规范", "author": "Rolan", "pub_time": "2019-5-5 00:42", "content": "出现 JavaScript 异常可能导致小程序的交互无法进行下去，我们应当追求零异常，保证小程序的高鲁棒性和高可用性，相信这一点一般情况下都不会出现，需要注意的是代码测试中多场景的试错。2.合理控制图片的大小图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。 一般情况下图片较大的，我们应该都会选择直接放在服务器上，直接拿到地址，但是官方说这样读取的图片： 存在网络图片资源未开启 HTTP 缓存控制 ,这是个什么意思，我也未完全弄懂。3.小程序所有请求应响应正常请求失败可能导致小程序的交互无法进行下去，应当保证所有请求都能成功。然而，请求成功只是第一步，还可能存在的问题就是请求的耗时太长、存在短时间内发起太多的请求这样的情况，一方面是后台人员的接口写的烂，一方面就是需求使然（技术半吊子，还想安全的产品经理会有这种让你去指定地方请求的情况），比如在阿里云OSS存储的一些json数据。。。。4.避免setData的数据过大且避免setData的调用过于频繁。由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间. setData接口的调用涉及逻辑层与渲染层间的线程通过，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用.5.避免将未绑定在 WXML 的变量传入 setDatasetData操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入setData会造成不必要的性能消耗。 这一条我想是很多开发人员在初次接触小程序开发的时候都会犯的一个错误吧。因为刚开始的时候由于这种setData的语法，让我们忘了还有全局变量的使用，于是会经常出现使用Page中定义的data做中间过渡。6.wxss 覆盖率较高，较少或没有引入未被使用的样式我们应该按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度。 这个也是比较常见的一种不规范，写了很多CSS样式，很多不用的就留来了代码里面，越来越多，所以在编写代码过程中，尽量去对每一行代码（特别是自己写的）了如指掌。7.避免首屏时间太长的情况首屏时间是指用户开始看到第一屏的内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，会一直等待有意义的内容展示出来。出现这一情况，应仔细检查这个过程都有哪个操作，一般来说，可能是请求数据的时间太长，或者是一次渲染的数据太大导致渲染时间太长。这些东西是我感觉比较常见且容易修改的，其它还存在一些规范，不妨打开微信开发者工具，点击 Audits ,对你写的代码进行一个测试，测试结果会让你很好的处理自己的代码。That's really cool!"}
{"title": "微信小程序怎么使用icon", "author": "Rolan", "pub_time": "2019-4-30 00:21", "content": "小程序怎么使用icon第一步 下载icon我选择的图标库是阿里图标官网， 加入购物车第二步 转换ttf因为小程序的wxss文件的font-face的url不接受http地址作为参数,但可以接受base64,因此需将字体文件下载后,转换为base64，然后引用进入https://transfonter.org/平台点击Add fonts，添加iconfont.ttf勾选Base64 encode点击 convert 完成转换按照上图1,2,3的步骤 转换完成， 点击Download第三步 在微信小程序中使用icon解压 第二步中的文件夹找到stylesheet.css 文件打开第一步中压缩包的iconfont.css，把里面圈红的部分（即fontface部分我们不需要啦）复制到stylesheet.css修改后的stylesheet.css修改stylesheet.css的文件后缀为wxss，即stylesheet.wxss把stylesheet.wxss放进微信小程序的公共文件里面，然后把整个文件import到页面的样式表里在wxml页面引入使用完结"}
{"title": "微信小程序生命周期与性能指标", "author": "Rolan", "pub_time": "2019-5-5 00:47", "content": "本文将介绍微信小程序整个App的生命周期、单个页面的生命周期和组件的生命周期，并研究了这三个元素生命周期的关系，这在学习和开发过程中对理解小程序运行机制有重要意义。最终，由生命周期整理出小程序的关键指标，仅供参考。App的生命周期在app.js中有其生命周期相关的三个方法：onLaunch、onShow和onHide。首先是onLaunch，这是整个小程序的第一个生命周期回调函数，在小程序初始化完成后调用。接着，小程序将触发onShow事件，如果小程序从后台切回前台后也会触发该事件。最后，是小程序切到后台的事件onHide。Page的生命周期在每个页面注册函数Page()的参数中，有生命周期的方法：onLoad、onShow、onReady、onHide、onUnload。页面触发的第一个生命周期回调是onLoad，在页面加载的时候触发，其参数是页面的query参数，一个页面只有一次；接着是onShow，监听页面的显示，与onLoad不同，如果页面被隐藏后再次显示（例如：进入下一页后返回），也会触发该生命周期；触发onShow之后，逻辑层会向渲染层发送初始化数据，渲染层完成第一次渲染之后，会通知逻辑层触发onReady生命周期，一个页面只有一次；onHide是页面隐藏但未卸载的时候触发的，如 wx.navigateTo 或底部tab切换到其他页面，小程序切入后台等。onUnload是页面卸载时触发，如wx.redirectTo或wx.navigateBack到其他页面时。Component的生命周期组件最重要的生命周期是created、attached、detached ，包含一个组件实例生命流程的最主要时间点。首先，当组件实例刚被创建时， created生命周期被触发。此时，还不能调用setData 。 通常情况下，这个生命周期只应该用于给组件this添加一些自定义属性字段。接着，在组件完全初始化完毕并且进入页面节点树后， attached生命周期被触发。此时， this.data 已被初始化为组件的当前值，绝大多数初始化工作可以在这个时机进行。在组件离开页面节点树后， detached生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。此外，组件生命周期还有ready和move生命周期，分别在视图层布局完成和组件实例被移动到节点树另一个位置时执行。整体周期现在我们知道了App、Page、和Component分别的生命周期顺序，那么他们之间的生命周期顺序又是如何？通过开发一个简单的demo，观察运行结果，可以得到如下结论：打开页面的情况首先，前一个页面隐藏，在加载下一个页面之前，需要先初始化新页面的组件。页面首次渲染之后，会触发组件的ready，最后触发的是页面的onReady，如下图：从PageA打开pageB时的生命周期顺序离开页面的情况离开当前页面时，首先触发当前页面的卸载onUnload，接着是组件离开节点树的detached。最后显示之前的页面，触发onShow。如下图：从PageB返回到PageA的生命周期顺序打开App的情况App、Page与Component生命周期运行顺序，先从App加载然后再加载Page，在加载Page之前会先初始化该页面所用的所有组件，之后才触发页面的onLoad生命周期，如下图：打开App时的生命周期顺序切换到后台切换到后台时，小程序和页面并没有卸载，只会触发隐藏。先触发页面的onHide，接着是App的onHide。如下图：切换到后台时的生命周期顺序切换到前台切换到后台时，小程序会先触发onShow，之后才是页面的onShow。如下图：切换到前台时的生命周期顺序关键性能指标了解了小程序各个阶段的生命周期，我们可以制定出关键节点的性能指标，整理如下表：参考文档官方文档 Page：developers.weixin.qq.com/miniprogram…官方文档 App：developers.weixin.qq.com/miniprogram…官方文档 页面生命周期：developers.weixin.qq.com/miniprogram…官方文档 组件生命周期：developers.weixin.qq.com/miniprogram…"}
{"title": "手把手教你写一个微信小程序日历组件", "author": "Rolan", "pub_time": "2019-5-6 00:24", "content": "今天我们一起写一个微信小程序日历组件\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n好，我们先看一下要实现的模样，如下图\r\n\r\n\r\n由以上截图我们可以看到\r\n\r\n1.日历可以通过按钮【切换展示效果】改变日历的呈现效果，上图是平铺模式，下图是收起滚动模式。\r\n2.通过点击具体的日期可以在页面上显示当前选中的具体日期。\r\n3.点击【今天】快速回到当日视图。\r\n4.点击【◀】和【▶】切换月份。\r\n上面的四点也是基本的交互需求，我们马上开始。\r\n首先，我们先结构后样式，做出最基本的界面结构\r\n这边我们把整体结构分成上中下，操作显示区，星期显示区，日期显示区。\r\n\r\n<view class='calendar'>\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n\r\n    <!--星期-->\r\n    <view class='calendar-week'>\r\n        <view class='item'>{{item}}</view>\r\n    </view>\r\n\r\n    <!--日期-->\r\n    <view class='calendar-container'>\r\n        <!--上个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n\r\n        <!--当月格子-->\r\n        <view class='grid'>\r\n            <view class=\"wrap\">{{item.date}}</view>\r\n        </view>\r\n\r\n        <!--下个月占位格子-->\r\n        <view class='grid gray'>{{item}}</view>\r\n    </view>\r\n</view>\r\n复制代码这是我们基本的日历结构，机智的小伙伴已经从布局中知道我们实现的大致逻辑了，是的，我们先获取当月有多少天，上月和下月有多少天，这样我们的日历就出来了。好，慢慢来，下面我们详细说，我们先写上基本的样式。\r\n.calendar {\r\n    width: 100%;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* 标题 */\r\n.calendar-title {\r\n    line-height: 70rpx;\r\n    font-size: 30rpx;\r\n    text-align: left;\r\n    padding: 0 20rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-title .ctrl {\r\n    display: inline-block;\r\n    padding: 0 20rpx;\r\n    background: #f5f5f5;\r\n    border-radius: 10rpx;\r\n}\r\n\r\n.calendar-title .item {\r\n    display: inline-block;\r\n    vertical-align: middle;\r\n    line-height: 50rpx;\r\n}\r\n\r\n.calendar-title .title {\r\n    min-width: 300rpx;\r\n    text-align: center;\r\n}\r\n\r\n.calendar-title .today {\r\n    float: right;\r\n    margin-top: 10rpx;\r\n}\r\n\r\n/* 星期 */\r\n.calendar-week {\r\n    display: flex;\r\n    text-align: center;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n    border-top: 1rpx solid #e0e0e0;\r\n    border-bottom: 1rpx solid #e0e0e0;\r\n    background: #f5f5f5;\r\n}\r\n\r\n.calendar-week .item {\r\n    flex: 1;\r\n}\r\n\r\n/* 日期 */\r\n.calendar-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    padding: 20rpx 10rpx;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.calendar-container .grid {\r\n    display: inline-block;\r\n    width: 14.28571428571429%;\r\n    line-height: 70rpx;\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.calendar-container .grid.gray {\r\n    color: #ccc;\r\n}\r\n\r\n.calendar-container .grid .wrap.select {\r\n    background: rgb(49, 120, 228);\r\n    border-radius: 10rpx;\r\n    color: #fff;\r\n    width: 80%;\r\n    margin: 0 auto;\r\n}\r\n复制代码以上我们基本试下了日历的界面，下面我们来实现星期和日期的展示。\r\n好，我们先显示星期，我们先在组件中定义一个数组，用来遍历显示星期的标题；\r\nComponent({\r\n    properties: {\r\n        //星期数组\r\n        weekText: {\r\n            type: Array,\r\n            value: ['周日', '周一', '周二', '周三', '周四', '周五', '周六']\r\n        }\r\n    },\r\n    ...\r\n})\r\n复制代码我们将星期的标题定义为可配置的模式，默认显示如上的文字，之后我们可以在组件外自定义，个性化显示。于是我们调整下wxml的代码。\r\n    <!--遍历星期-->\r\n    <view class='calendar-week'>\r\n        <view wx:for='{{weekText}}' class='item' wx:key='{{item}}'>{{item}}</view>\r\n    </view>\r\n复制代码这样我们就能看到我们想要的效果。\r\n\r\n下面我们开始日期的显示，我们先获取当月有几天，这里的核心代码是\r\n\r\nnew Date(year, month, date).getDate();\r\n\r\n\r\n由此我们做如下尝试\r\n\r\n我们如期获得了返回值，而当我们传入日期为0时返回了31为当月的全部天数。\r\n\r\n由于JavaScript中day的范围为1~31中的值，所以当设为0时，会向前 一天，也即表示上个月的最后一天，通过这种方式可以得到每个月份的天数。\r\n\r\n知道了获取当月天数的原理，我们还需要知道当月1号是星期几。\r\n我们使用如下的方法：\r\n\r\nnew Date(Date.UTC(year, month-1, date)).getDay();\r\n\r\n\r\n我们同样在控制台做出调试；\r\n\r\n需要注意的是，上面的month是实际的月份，而下面这个方法需要在实际的月份上减去1。\r\n于是我们获取0-6之间的值，分别对应周日~周六。\r\n值为6是周六，值为0是周日。\r\n由于日历的第一天是周日，周日对应的是0，于是传入每月1日，返回值为多少，就是星期几，也就说明当月1日前面空几格。\r\n知道了当月就几天，当月前面有几天，我们做一下算法就可以得出，当月后面有几天，于是我们建立如下函数：\r\n    // 组件的初始数据\r\n    data: {\r\n        //当月格子\r\n        thisMonthDays: [],\r\n        //上月格子\r\n        empytGridsBefore: [],\r\n        //下月格子\r\n        empytGridsAfter: [],\r\n},\r\n\r\nmethods: {\r\n        //获取当月天数\r\n        getThisMonthDays: function (year, month) {\r\n            return new Date(year, month, 0).getDate();\r\n        },\r\n        // 绘制当月天数占的格子\r\n        createDays: function (year, month) {\r\n            let thisMonthDays = [],\r\n                days = this.getThisMonthDays(year, month);\r\n            for (let i = 1; i <= days; i++) {\r\n                thisMonthDays.push({\r\n                    date: i,\r\n                    dateFormat: this.zero(i),\r\n                    monthFormat: this.zero(month),\r\n                    week: this.data.weekText[new Date(Date.UTC(year, month - 1, i)).getDay()]\r\n                });\r\n            }\r\n            this.setData({\r\n                thisMonthDays\r\n            })\r\n        },\r\n        //获取当月空出的天数\r\n        createEmptyGrids: function (year, month) {\r\n            let week = new Date(Date.UTC(year, month - 1, 1)).getDay(),\r\n                empytGridsBefore = [],\r\n                empytGridsAfter = [],\r\n                emptyDays = (week == 0 ? 7 : week);\r\n            //当月天数\r\n            var thisMonthDays = this.getThisMonthDays(year, month);\r\n            //上月天数\r\n            var preMonthDays = month - 1 < 0 \r\n                ? this.getThisMonthDays(year - 1, 12) \r\n                : this.getThisMonthDays(year, month - 1);\r\n\r\n            //空出日期\r\n            for (let i = 1; i <= emptyDays; i++) {\r\n                empytGridsBefore.push(preMonthDays - (emptyDays - i));\r\n            }\r\n\r\n            var after = (42 - thisMonthDays - emptyDays) - 7 >= 0 \r\n                        ? (42 - thisMonthDays - emptyDays) - 7 \r\n                        : (42 - thisMonthDays - emptyDays);\r\n            for (let i = 1; i <= after; i++) {\r\n                empytGridsAfter.push(i);\r\n            }\r\n            this.setData({\r\n                empytGridsAfter,\r\n                empytGridsBefore\r\n            })\r\n        },\r\n\r\n        //补全0\r\n        zero: function (i) {\r\n            return i >= 10 ? i : '0' + i;\r\n        },\r\n}\r\n复制代码我们同样修改下wxml代码，同时我们为上月，下月，今天，三个按钮添加相关事件监听。\r\n    <!--显示当前年月日-->\r\n    <view class='calendar-title'>\r\n        <view class='item ctrl' bindtap='lastMonth'>{{lastMonth}}</view>\r\n        <view class='item title'>{{title}}</view>\r\n        <view class='item ctrl' bindtap='nextMonth'>{{nextMonth}}</view>\r\n        <view class='item ctrl today' bindtap='today'>今天</view>\r\n    </view>\r\n复制代码<!--上个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsBefore}}' wx:key='{{item}}'>{{item}}</view>\r\n\r\n<!--当月格子-->\r\n<view class='grid' wx:for='{{thisMonthDays}}' wx:key='{{indx}}'>\r\n   <view class='self' wx:if=\"{{ format === year+'-'+item.monthFormat+'-'+item.dateFormat }}\"></view>\r\n   <view class=\"wrap {{ select === year+'-'+item.monthFormat+'-'+item.dateFormat ? 'select' :''}}\" bindtap='select' data-date='{{item.date}}'>{{item.date}}</view>\r\n</view>\r\n\r\n<!--下个月占位格子-->\r\n<view class='grid gray' wx:for='{{empytGridsAfter}}' wx:key='{{item}}'>{{item}}</view>\r\n复制代码相关的事件监听：\r\n//默认选中当天 并初始化组件\r\ntoday: function () {\r\n    let DATE = this.data.defaultValue ? new Date(this.data.defaultValue) : new Date(),\r\n        year = DATE.getFullYear(),\r\n        month = DATE.getMonth() + 1,\r\n        date = DATE.getDate(),\r\n        select = year + '-' + this.zero(month) + '-' + this.zero(date);\r\n\r\n    this.setData({\r\n        format: select,\r\n        select: select,\r\n        year: year,\r\n        month: month,\r\n        date: date,\r\n        YEAR: year,\r\n        MONTH: month,\r\n        DATE: date,\r\n    })\r\n\r\n    //初始化日历组件UI\r\n    this.display(year, month, date);\r\n\r\n    //发送事件监听\r\n    this.triggerEvent('select', select);\r\n},\r\n//上个月\r\nlastMonth: function () {\r\n    let month = this.data.month == 1 ? 12 : this.data.month - 1;\r\n    let year = this.data.month == 1 ? this.data.year - 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n//下个月\r\nnextMonth: function () {\r\n    let month = this.data.month == 12 ? 1 : this.data.month + 1;\r\n    let year = this.data.month == 12 ? this.data.year + 1 : this.data.year;\r\n    //初始化日历组件UI\r\n    this.display(year, month, 0);\r\n},\r\n复制代码代码中我们使用this.display(year, month, 0)为组件统一初始化；\r\n同时在today函数中我们添加事件监听函数，将选中的日期发送到页面，我们通过事件订阅来获取的相关值。\r\n<Calendar id=\"Calendar\" bind:select=\"select\"></Calendar>\r\n复制代码//组件监听事件\r\nselect(e) {\r\n    this.setData({\r\n        selectVal:e.detail\r\n    })\r\n},\r\n复制代码最后我们为切换显示效果的按钮添加事件：\r\n    toggleType(){\r\n        this.selectComponent('#Calendar').toggleType();\r\n    }\r\n复制代码组件中对应的方法，每当切换展示效果，组件都需要初始化\r\n        //切换展示\r\n        toggleType(){\r\n            this.setData({\r\n                toggleType: this.data.toggleType == 'mini' ? 'large' :'mini'\r\n            })\r\n            //初始化日历组件UI\r\n            this.display(this.data.year, this.data.month, this.data.date);\r\n        },\r\n复制代码以上基本上是小程序日历组件实现的基本逻辑，介于篇幅太长还有很多实现上的细节不在此一一细说，大家可以移步我的github\r\n\r\n微信小程序日历组件\r\ngithub.com/749264345/w…\r\n\r\n上文中有不足之处，请给出建议或更优的实现方案，谢谢~\r\n最后祝大家五一快乐~~"}
{"title": "微信小程序---支付密码的输入框", "author": "Rolan", "pub_time": "2019-5-6 00:51", "content": "效果如下：干货：<view class=\"pay\"><view class=\"title\">支付方式</view><view catchtap=\"wx_pay\" class=\"wx_pay\"><i class=\"icon {{payment_mode==1?'active':''}}\" type=\"String\"></i><text>微信支付</text></view><view catchtap=\"offline_pay\" class=\"offline_pay\"><i class=\"icon {{payment_mode==0?'active':''}}\" type=\"String\"></i><text>对公打款</text></view><block wx:if=\"{{balance!=0}}\"><view catchtap=\"wallet_pay\" class=\"wallet_pay\"><i class=\"icon {{payment_mode==2?'active':''}}\" type=\"String\"></i><text>钱包支付(余额:{{balance/100}}元)</text></view></block><block wx:if=\"{{balance==0}}\"><view class=\"wallet_pay\"><i class=\"icon\" type=\"String\" style=\"background:#e8e8e8;border:none;\"></i><text style=\"color:#999\">钱包支付(余额不足)</text></view></block></view><view catchtap=\"pay\" class=\"save\">确定</view><!--输入钱包密码--><view wx:if=\"{{wallets_password_flag}}\" class=\"wallets-password\"><view class=\"input-content-wrap\"><view class=\"top\"><view catchtap=\"close_wallets_password\" class=\"close\">×</view><view class=\"txt\">请输入支付密码</view><view catchtap=\"modify_password\" class=\"forget\">忘记密码</view></view><view class=\"actual_fee\"><span>￥</span><text>{{actual_fee/100}}</text></view><view catchtap=\"set_Focus\" class=\"input-password-wrap\"><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=1}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=2}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=3}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=4}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=5}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=6}}\"></i></view></view></view><input bindinput=\"set_wallets_password\" class=\"input-content\" password type=\"number\" focus=\"{{isFocus}}\" maxlength=\"6\" /></view>//index.jsPage({  data: {    payment_mode: 1,//默认支付方式 微信支付    isFocus: false,//控制input 聚焦    balance:100,//余额    actual_fee:20,//待支付    wallets_password_flag:false//密码输入遮罩  },  //事件处理函数  onLoad: function () {  },  wx_pay() {//转换为微信支付    this.setData({      payment_mode: 1    })  },  offline_pay() {//转换为转账支付    this.setData({      payment_mode: 0    })  },  wallet_pay() {    this.setData({//转换为钱包支付      payment_mode: 2    })  },  set_wallets_password(e) {//获取钱包密码    this.setData({      wallets_password: e.detail.value    });    if (this.data.wallets_password.length == 6) {//密码长度6位时，自动验证钱包支付结果      wallet_pay(this)    }  },  set_Focus() {//聚焦input    console.log('isFocus', this.data.isFocus)    this.setData({      isFocus: true    })  },  set_notFocus() {//失去焦点    this.setData({      isFocus: false    })  },  close_wallets_password () {//关闭钱包输入密码遮罩    this.setData({      isFocus: false,//失去焦点      wallets_password_flag: false,    })  },  pay() {//去支付    pay(this)  }})/*-----------------------------------------------*//*支付*/function pay(_this) {  let apikey = _this.data.apikey;  let id = _this.data.id;  let payment_mode = _this.data.payment_mode  if (payment_mode == 1) {  //  微信支付  // 微信自带密码输入框    console.log('微信支付')  } else if (payment_mode == 0) {  //  转账支付 后续跳转至传转账单照片    console.log('转账支付')  } else if (payment_mode == 2) {    // 钱包支付 输入密码    console.log('钱包支付')    _this.setData({      wallets_password_flag: true,      isFocus: true    })  }}// 钱包支付function wallet_pay(_this) {  console.log('钱包支付请求函数')  /*  1.支付成功  2.支付失败：提示；清空密码；自动聚焦isFocus:true，拉起键盘再次输入  */}index.wxsspage {  height: 100%;  width: 100%;  background: #e8e8e8;}page .pay {  display: flex;  flex-direction: column;  background: #fff;}page .pay .title {  height: 90rpx;  line-height: 90rpx;  font-size: 28rpx;  color: #353535;  padding: 0 23rpx;  border-bottom: 1rpx solid #ddd;  box-sizing: border-box;}page .pay .wx_pay, page .pay .offline_pay, page .pay .wallet_pay {  margin: 0 26rpx;  height: 90rpx;  line-height: 90rpx;  border-bottom: 2rpx solid #ddd;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: flex-start;}page .pay .wx_pay .icon, page .pay .offline_pay .icon,page .pay .wallet_pay .icon {  width: 34rpx;  height: 34rpx;  border: 2rpx solid #ddd;  box-sizing: border-box;  border-radius: 50%;}page .pay .wx_pay .icon.active, page .pay .offline_pay .icon.active,page .pay .wallet_pay .icon.active {  border: 10rpx solid #00a2ff;}page .pay .wx_pay text, page .pay .offline_pay text, page .pay .wallet_pay text {  margin-left: 20rpx;  color: #353535;  font-size: 26rpx;}page .pay .wallet_pay {  border: 0;  border-top: 2rpx solid #ddd;}page .pay .offline_pay {  border: 0 none;}page .save {  margin: 80rpx 23rpx;  color: #fff;  background: #00a2ff;  height: 88rpx;  line-height: 88rpx;  text-align: center;  font-size: 30rpx;  border-radius: 10rpx;}page .wallets-password {  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, 0.6);}page .wallets-password .input-content-wrap {  position: absolute;  top: 200rpx;  left: 50%;  display: flex;  flex-direction: column;  width: 600rpx;  margin-left: -300rpx;  background: #fff;  border-radius: 20rpx;}page .wallets-password .input-content-wrap .top {  display: flex;  align-items: center;  height: 90rpx;  border-bottom: 2rpx solid #ddd;  justify-content: space-around;}page .wallets-password .input-content-wrap .top .close {  font-size: 44rpx;  color: #999;  font-weight: 100;}page .wallets-password .input-content-wrap .top .forget {  color: #00a2ff;  font-size: 22rpx;}page .wallets-password .input-content-wrap .actual_fee {  display: flex;  align-items: center;  justify-content: center;  color: #000;  height: 100rpx;  margin: 0 23rpx;  border-bottom: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .actual_fee span {  font-size: 24rpx;}page .wallets-password .input-content-wrap .actual_fee text {  font-size: 36rpx;}page .wallets-password .input-content-wrap .input-password-wrap {  display: flex;  align-items: center;  justify-content: center;  height: 150rpx;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot {  display: flex;  align-items: center;  justify-content: center;  text-align: center;  color: #000;  box-sizing: border-box;  width: 90rpx;  height: 90rpx;  border: 2rpx solid #ddd;  border-left: none 0;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot:nth-child(1) {  border-left: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot i {  background: #000;  border-radius: 50%;  width: 20rpx;  height: 20rpx;}page .wallets-password .input-content {  position: absolute;  opacity: 0;  left: -100%;  top: 600rpx;  background: #f56;  z-index: -999;}page .wallets-password .input-content.active {  z-index: -99;}github地址：-\">https://github.com/fiveTree/--"}
{"title": "微信小程序全屏模式（自定义导航栏）", "author": "Rolan", "pub_time": "2019-5-6 00:53", "content": "导航栏背景图要自定义导航栏，首先需要在app.json里设置：{\"window\": {        \"navigationStyle\": \"custom\"    }}设置之后进入小程序就只剩下右上角的胶囊了。 在设置导航栏样式时需要知道它的高度，在app.json的onLaunch里获取状态栏高度：App({    onLaunch: function(options) {        wx.getSystemInfo({            success: (res) => {                this.globalData.statusBarHeight = res.statusBarHeight                this.globalData.navBarHeight = 44 + res.statusBarHeight            }        })    },    globalData: {        statusBarHeight: 0,        screenHeight: 0    }})44是导航栏除去状态栏的高度，单位px。 因为导航栏每个页面都会用到，所以我们用组件会方便使用一些，这里创建一个叫nav的组件： 首先在组件js里设置statusBarHeight和一个可以通过外部设置状态栏颜色的backgroundColor的属性，默认透明。 nav.js:const app = getApp()Component({    options: {        multipleSlots: true    },    properties: {        backgroundColor:{            type: String,            value: 'rgba(0,0,0,0)'        }    },    data: {},    ready() {        let {            statusBarHeight,            navBarHeight        } = app.globalData;        this.setData({            statusBarHeight,            navBarHeight        })    },    methods: {        back() {            wx.navigateBack({                delta:1            })        }    }})content里放置内容，返回按钮固定在左边。 nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <slot name=\"content\"></slot>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:.nav-wrap {    position: fixed;    top: 0;    left: 0;    width: 750rpx;    z-index: 1;}.content {    position: relative;    width: 100%;    height: 44px;}.back {    position: absolute;    left: 0;    top: 0;    width: 88px;    height: 44px;    background: pink;}在页面中使用：<nav bgColor=\"black\">    <view slot=\"content\">        <view class='txt'>Nav title</view>    </view></nav><view>page content</view>效果图：效果图这里txt里的样式、内容都是可以自定义的，如果想要使用通用样式，可以写在组件里。 比如把导航栏title放在组件里，通过外部传值设置： nav.js:Component({    // ...    properties: {        title:{            type: String,            value: ''        }    },    // ...})nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:/* ... */.title {    color: white;    text-align: center;    line-height: 44px;    font-weight: 500;}/* ... */调用就可以了。 在第一次使用nav组件的页面代码中，page content是看不见的，因为是直接从状态栏开始显示的，被nav挡住了。 这里可以加一个高度为导航栏高度的view当做顶部padding： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>这里在properties里设置了一个hastop，用来控制是否有顶部padding。 页面中：<nav bgColor=\"black\" title=\"Nav title\" hastop></nav><view>page content</view>这样就可以显示出来了：导航栏背景图 还可以做导航栏背景图，添加一个image，绝对定位放置在nav-wrap底部： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <image class='bgimg' wx:if=\"{{bgsrc}}\" src='{{bgsrc}}' mode='aspectFill'></image>    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class='title'>{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>nav.wxss.bgimg {    position: absolute;    left: 0;    top: 0;    width: 100%;    height: 100%;}页面：<nav bgColor=\"black\" title=\"Nav title\" hastop bgsrc=\"/images/bg.jpeg\"></nav><view>page content</view>导航栏背景图全屏背景 将bgColor、hastop、bgsrc都去掉，在页面中放置一个position: fixed;，并且铺满全屏的图片。<nav title=\"Nav title\"></nav><image class='pagebg' src='/images/bg.jpeg' mode='aspectFill'></image>全屏背景back的内容自定义就行了，我这里只是简单放置了一个色框。注意事项 官方文档中的注意事项：注1：HexColor（十六进制颜色值），如\"#ff00ff\" 注2：关于navigationStyle客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉"}
{"title": "[UI组件] 来做一个可配置的滑块进度条吧", "author": "Rolan", "pub_time": "2019-5-7 00:32", "content": "在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, 宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。Component({\r\n    /**\r\n     * 组件的属性列表\r\n     */\r\n    properties: {\r\n        // 滑块大小\r\n        blockSize: {\r\n            type: Number,\r\n            value: 32,\r\n        },\r\n\r\n        // 滑块宽度\r\n        blockBorderWidth: {\r\n            type: Number,\r\n            value: 3\r\n        },\r\n\r\n        // 滑轨高度\r\n        height: {\r\n            type: Number,\r\n            value: 2\r\n        },\r\n\r\n        // 滑轨进度\r\n        step: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n\r\n        // 进度值小数位\r\n        digits: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n    },\r\n});<view id=\"slider-wrap\" class=\"slider-wrap\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view  class=\"silder-bg-inner\"></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>.slider-wrap {\r\n    position: relative;\r\n    display: flex;\r\n    align-items: center;\r\n    width: 100%;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner,\r\n.silder-block {\r\n    position: absolute;\r\n    left: 0;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner {\r\n    width: 100%;\r\n    height: 2rpx;\r\n    flex: 1;\r\n}\r\n\r\n.silder-bg {\r\n    overflow: hidden;\r\n    background-color: #eeeeee;\r\n    border-radius: 8rpx;\r\n    z-index: 0;\r\n}\r\n\r\n.silder-bg-inner {\r\n    height: 100%;\r\n    background-color: #66a6ff;\r\n    /* border-radius: 8rpx; */\r\n    z-index: 1;\r\n    border-bottom-left-radius: 8rpx;\r\n    border-top-left-radius: 8rpx;\r\n}\r\n\r\n.silder-block {\r\n    width: 32rpx;\r\n    height: 32rpx;\r\n    background-color: #ffffff;\r\n    border: solid 3rpx #66a6ff;\r\n    z-index: 2;\r\n    border-radius: 50%;\r\n    box-sizing: border-box;\r\n}\r\n点击行为事件滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条如下图所示：((191 - 36) / 301) * 100 ≈ 52<view class=\"slider-wrap\" bindtap=\"tappingSlider\">\r\n    <!-- ...other -->\r\n</view>Component({\r\n    // ...\r\n\r\n    /**\r\n     * 组件的初始数据\r\n     */\r\n    data: {\r\n        containerInfo: null,\r\n        percentage: 0,\r\n    },\r\n\r\n    ready() {\r\n        // 取到滑块进度条的位置信息\r\n        wx.createSelectorQuery().in(this)\r\n            .select('.slider-wrap')\r\n            .boundingClientRect((rect) => {\r\n                if (!rect) return;\r\n\r\n                this.data.container = rect;\r\n                this._initBloackPos();\r\n            }).exec()\r\n    },\r\n\r\n    // 点击进度条\r\n    tappingSlider(evt) {\r\n        const { containerInfo } = this.data;\r\n        if (!containerInfo) return;\r\n\r\n        const { clientX } = evt.changedTouches[0];\r\n        const { digits, _maxDistance } = this.data;\r\n\r\n        // 需要做边界处理\r\n        const perc = this._computeOffset(clientX, containerInfo.left, 100);\r\n        const percentage = this._boundaryHandler(perc);\r\n\r\n        this.setData({ percentage });\r\n        this.triggerEvent('change', {\r\n              value: percentage.toFixed(digits) * 1\r\n          });\r\n    },\r\n\r\n    /**\r\n     * 计算相对容器的偏移距离\r\n     *\r\n     * @param { Number } x - X 坐标\r\n     * @param { Number } offset - 偏移量\r\n     * @param { Number } maxVal - 在 maxVal 范围内求百分比\r\n     */\r\n    _computeOffset(x, offset, maxVal) {\r\n        const { width } = this.data.containerInfo;\r\n\r\n        // 底层保证一定精度\r\n        return (((x - offset) / width) * maxVal).toFixed(4) * 1;\r\n    },\r\n\r\n    /**\r\n     * 边界处理\r\n     * @param { Number } num - 待处理的最值\r\n     * @param { Number } maxNum - num 最大值\r\n     * @param { Number } minNum - num 最小值\r\n     */\r\n    _boundaryHandler(num, maxNum = 100, minNum = 0) {\r\n        return num > maxNum ? maxNum : (num < minNum ? minNum : num);\r\n    },\r\n});<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{percentage}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ 当我们点击到百分百时，滑块超出原先设定的容器宽度。超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量：Component({\r\n    // ...\r\n    data: {\r\n        // other data...\r\n\r\n        _blockOffset: 0,\r\n        _maxDistance: 100,\r\n    },\r\n\r\n    methods: {\r\n        // 点击进度条\r\n        tappingSlider(evt) {\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n\r\n})<!-- other code -->\r\n<view\r\n    class=\"silder-block\"\r\n    style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n></view>如此，该事件就完成啦~滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块 -> 拖动滑块 -> 释放滑块这三个步骤。因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, 随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可：Component({\r\n    methods: {\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = this.data._blockOffset;\r\n            this.data.originPercentage = this.data.percentage;\r\n\r\n            this.data._startTouchX = evt.changedTouches[0].clientX;\r\n        },\r\n\r\n        // 滑块移动\r\n        onTouchMove(evt) {\r\n            const { moving, containerInfo } = this.data;\r\n            if (!moving || !containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const {\r\n                digits,\r\n                originPos,\r\n                originPercentage,\r\n                _startTouchX,\r\n                _maxDistance\r\n            } = this.data;\r\n\r\n            // 计算偏移量\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, _startTouchX, maxVal);\r\n            }\r\n\r\n            // 实际百分比\r\n            const perc = originPercentage + computeOffset(100);\r\n            const percentage = this._boundaryHandler(perc);\r\n\r\n            // 滑块偏移度\r\n            const offset = originPos + computeOffset(_maxDistance);\r\n            const _blockOffset = this._boundaryHandler(offset, _maxDistance);\r\n\r\n            this.setData({ percentage, _blockOffset });\r\n            this.triggerEvent('change', {\r\n                value: percentage.toFixed(digits) * 1\r\n            });\r\n        },\r\n\r\n        onTouchEnd(evt) {\r\n            this.data.moving = false;\r\n        },\r\n    }\r\n})<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n        bindtouchstart=\"onTouchStart\"\r\n        bindtouchend=\"onTouchEnd\"\r\n    ></view>\r\n</view>总结以上就是滑块进度条组件的实现~ 实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 API 的差异罢了~微信代码片段, 可以直接拿来就用。2019/05/04 更新：后面又重新看了一遍，发现该组件还是有可优化的空间：操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动:<view class=\"slider-wrap\"\r\n    bindtouchstart=\"onTouchStart\"\r\n    bindtouchmove=\"onTouchMove\"\r\n    bindtouchend=\"onTouchEnd\"\r\n>\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>Component({\r\n    // other options ...\r\n\r\n    methods: {\r\n        // other method ...\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = _blockOffset;\r\n            this.data.originPercentage = percentage;\r\n\r\n            this.data._startTouchX = clientX;\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n});微信代码片段 v0.0.2"}
{"title": "微信小程序如何将图片画到canvas中", "author": "Rolan", "pub_time": "2019-4-17 00:16", "content": "微信小程序开发第二弹:canvas是新的h5标签，相信在前端技术中大家使用的已经非常多了，但是在微信小程序开发中，应该如何将图片置入canvas中呢?这篇经验来和大家分享一下!工具/原料微信web开发者工具方法/步骤1:先是照样先写好一个html文件，不过由于是微信小程序，所以要按照wxml的标准来写。头尾文件都不需要，直接修改index.wxml,方法/步骤2:寻找一张准备置入的图片，保存在网络环境中。可以转换成base64，也可以保存在自己的服务器端。本地调试的时候需要使用。我就拿这个小黄人来举例吧。方法/步骤3:在canvas内进行图像绘制，要先定义一个函数。方法/步骤4:我们先建立一个动作，将图片置入进去。引用函数context.drawImage()函数即可，但是要调整图片大小;方法/步骤5:但是不能使用draw(true)来进行铺满，所以尺寸必须自己来指定，或者使用js来读取device的height和width。使图片达到预想的效果。方法/步骤6:微信小程序的WXML和HTML格式有点差别，不能直接调用函数，所以必须使用匿名函数的形式，或者直接绑定事件。方法/步骤7:最后是进行不同机型的调试，在微信开发工具左上方可以调整，主要是看不同尺寸显示问题，如果有必要还要进行wifi，4G，2G测试注意事项使用context.drawImage();的时候，还需要限制起始位置与图片大小这里仅仅提供思路，如果是制作页面，还需要使用wx.downloadFile"}
{"title": "小程序开发遇到的一些问题和吐槽", "author": "Rolan", "pub_time": "2019-4-17 00:32", "content": "小程序在微信这个超级平台的带动下，这两年着实是越来越火。刚出来那一阵，翻了翻文档简单的看了看，没有组件、没有wsx(虽然现在也很难用，有总比没有强)还有无穷无尽的坑。一直没有深入去学习去了解。期间美团开源了一个mpvue，一个基于Vue的小程序开发框架。上手没什么成本，自己写了一个极其简单简陋查询快递的小程序–快递去哪儿咯。最近工作上来了小程序的需求，组内交流之后打算用小程序原生的那一套搞。现学现搞all in了两周小程序。这里记录一下遇到的一些小问题或者坑吧。吐槽那我们就从吐槽开始（很喜欢的一部电影）繁琐过时的API在网页端开发web，说道处理请求相比axios、fetch已经成了主流，链式调用try···catch处理错误。但是小程序却用着过时的ES3风格的API(wx.request)。这样在使用起来很不优雅，在使用了调用的时候很容易造成回调地狱。想要使用promise这种链式调用的实行。我们不得不去封装一个HTTP类。下面是自己封装的一个HTTP类1234567891011121314151617181920212223242526272829303132export class HTTP {  request({ url, data={}, method=\"GET\" }) {    return new Promise((resolve, reject) => {      this._request(url, resolve, reject, data, method)    })  }  _request(url, resolve, reject, data={}, method=\"GET\") {    wx.request({      url: config.api_base_url + url,      method,      data,      header: {        'content-type': 'application/json'      },      success: (res) => {\t\t\t\tconst code = res.statusCode.toString()\t\t\t\t// 判断状态码        if (code.startsWith('2')) {          resolve(res.data)        } else {          reject()        }      },      fail: (err) => {        reject()      }    })  }}面向JSON编程接着API设计的过时，不得不吐槽这种面向JSON编程的方式。开发一个小程序需要app.json去配置全局的应用配置、路由配置还有全局UI配置。每个页面，每个组件也有相应json文件去配置。wxs真的很难用作为页面的脚本语言，微信这边自己现成的JS不用，自己搞了一套嵌入式脚本语言，里面只能写ES3的语法不说（还不是完整版的ES3语法）没有 Array, Object 对象；或遇到引入 lodash 会报错 TypeError: Cannot read property ‘prototype’ of undefinedjs页面中无法使用绝对路径wxss 里的注释只能用 /…/ 写法，不能用 //…component组件中与支持onShow这个生命周期遇到的一些问题在开发横向滑动图片的组件的时候，自然而然想到在sroll-view组件上添加scroll-x属性，但是依然划不动。解决：父级在设置宽高的同时必须设white-space: nowrap; 子级要用display: inline-block;用浮动都不行页面配置背景色可使用 backgroundColor,模拟器里并没有生效。最后发现backgroundColor 是指窗体背景颜色，而不是页面背景色。textarea组件是原生组件，placeholder-style 目前只支持设置 fontSize、fontWeight、color 属性map、textarea 为原生组件，页面层级最高，就算设置了z-index也无法被覆盖。（这个是真的坑）text组件，看名字我们自然而然想到这个是不是和网页中的span标签一样。但是两个text标签放在一起会出现高度不一致的问题，以及类似网页中的pre标签，会保留文本中的空格和换行符号（开发的时候发现怎么换行了，一个劲的调样式，结果发现=。=真的是无语）解决: 索性全换成view组件了发消息模版时需要获得提交表单时的 formId，通过 form 及键盘右下角完成提交事件对象 e.detail 获取不到 formId，只能通过 form button 来获取。component在处理数据变化的时候 可以使用properties中设置的observe或者页面中写wxs,wxs其实相当于vue里面的过滤器。这两个可以结合情况使用wx:if 和hidden结合实际情况适用。hidden不能直接赋值在自定义组件上，需要放在组件里的最外层的view上。用过传参的形式使用以上小程序的开发怎么说真的是又爱又恨，很是微妙。这两周的开发学习感觉又回到了当时研究RN的时候，当效果、成果做出来的时候很有成就感。同时小程序也蛮适合自己瞎搞的，最近在搞的一个repoTeemo,除此之外这两天小程序官方有公测了serverless，感觉发挥的空间更大了。最近自己还真有个好点子，等搞完这个尝试一波（自娱自乐）"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序如何调用后台service的简单记录", "author": "Rolan", "pub_time": "2019-1-31 00:24", "content": "写在前头，本篇文章简单记录一下，在前后端分离的微信小程序应用中，前端访问后台service的实现思路，没有过多涉及技术实现方面。先上一张官网的图片，它很清楚的讲明了要在后台service为每一个小程序用户提供登录信息需要做哪些事情。用户拿到了后台给的登录凭据，访问后台service。静默授权与非静默授权先来讲讲这两个概念， 静默授权，顾名思义，这授权动作对于用户来说是感知不到的， 小程序端悄咪咪得就做了。因此，没有知会用户的授权方式拿到的信息也是不太重要的。但是，静默授权是开始重要的一步，因为它为接下来的动作提供了code。调用静默授权可用小程序提供的 API:wx.login() 。再来讲讲 非静默授权，顾名思义，它的授权是要有明显动静的，而且它是要得到用户认可才可以执行。 API:wx.getUserInfo() ，这个接口要不要用可根据小程序的实际需求来。后台获取openId小程序提供了一个接口 code2session ，拿着我们静默授权获取到的临时登录凭证code再调用一下这个接口就能获取到openId了。注意，这一步是在后台服务器做的。openId是在当前小程序中对用户唯一性的标识。基于OAuth2.0生成token在后台，可以用SpringSecurity的OAuth2.0这一个工具，用openId来生成前端请求后端数据的附带校验信息token。具体是如何实现的笔者也没有深入了解……获取到了这个token后，前端可将其存入webStorage中，每一次调用后台service的时候，就可以利用请求的拦截器在config参数中加入token。后端就可以确定发送请求的用户身份，保证了系统的安全性。总结：以上大致描绘了小程序后台自定义登录态的开发思路。"}
{"title": "关于微信 setData 回调函数中的坑", "author": "Rolan", "pub_time": "2019-2-18 00:43", "content": "最近在做录音功能，需求大体是这样的：点击开始录音按钮，页面状态变为录音中，然后开始录音。不过伟大的测试同学发现了一个问题：当快速的连续点击开始录音按钮时，会触发多次开始录音的事件，这样在结束录音时就仍然会有一个正在录音中的标识，像这样:下面开始曲折的修复之路:最开始的代码是这样的:Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n      \r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n})这时我的猜测是：页面重新渲染之前，按钮还是显示状态，所以还能被点击。那既然这样，就加个标识，在一次点击之后，到页面重新渲染之前，都不能再次点击就好了，代码如下：Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n    // 录音开始按钮点击标识\r\n    this.isRecordBtnClicked = false\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    // 如果录音按钮已被点击(录音即将开始)，则不会再次触发开始录音事件\r\n    if (this.isRecordBtnClicked) {\r\n      return\r\n    }\r\n    this.isRecordBtnClicked = true\r\n\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      this.isRecordBtnClicked = false\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n})想法是好的，不过并没有实现想要的效果。还是可以被多次点击。于是在多次实验之后，改为如下的方式（可行）：Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n    // 录音开始按钮点击标识\r\n    this.isRecordBtnClicked = false\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n      // 将录音按钮的点击状态在录音开始时修改\r\n      this.isRecordBtnClicked = false\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    // 如果录音按钮已被点击(录音即将开始)，则不会再次触发开始录音事件\r\n    if (this.isRecordBtnClicked) {\r\n      return\r\n    }\r\n    this.isRecordBtnClicked = true\r\n\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n\r\n})将按钮的点击状态在录音开始事件中进行重置，就可以解决这个问题了。说一下最后验证的结果：setData() 方法的回调函数并不是在页面重新渲染完之后才执行的，所以并不能以回调函数作为一个明确的时间点来处理一些逻辑。而由于recorderManager.onStart() 方法触发时会有一定的延时，所以间接的解决了这个问题。"}
{"title": "小程序的登录与静默续期", "author": "Rolan", "pub_time": "2019-2-22 00:47", "content": "每一个有数据交互的小程序，都会涉及到登录、token 等问题，openid 又是什么呢？怎么使用静默续期，来提升用户体验呢？小程序登录登录时序一切的一切，都要从这么一张小程序登录时序图说起：通常情况下，我们的小程序都会有业务身份，如何将微信帐号和业务身份关联起来呢？这个时候我们需要上图的步骤：小程序调用wx.login()获取临时登录凭证code。小程序将code传到开发者服务器。开发者服务器以code换取用户唯一标识openid和会话密钥session_key。开发者服务器可绑定微信用户身份id和业务用户身份。开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。相关数据或参数上面的登录时序中，我们会涉及到一些数据和参数，先来了解下它们都是用来做啥的。临时登录凭证 code在小程序中调用wx.login()，能拿到一个code作为用户登录凭证（有效期五分钟）。在开发者服务器后台，开发者可使用code换取openid和session_key等信息（code只能使用一次）。code的设计，主要用于防止黑客使用穷举等方式把业务侧个人信息数据全拉走。AppId 与 AppSecret为了确保拿code过来换取身份信息的人就是对应的小程序开发者，到微信服务器的请求要同时带上AppId和AppSecret。session_key会话密钥session_key是对用户数据进行加密签名的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。设计session_key主要是为了节省流程消耗，如果每次都通过小程序前端wx.login()生成微信登录凭证code去微信服务器请求信息，步骤太多会造成整体耗时比较严重。使用接口wx.checkSession()可以校验session_key是否有效。用户越频繁使用小程序，session_key有效期越长。session_key失效时，可以通过重新执行登录流程获取有效的session_key。openidopenid是微信用户id，可以用这个id来区分不同的微信用户。微信针对不同的用户在不同的应用下都有唯一的一个openid, 但是要想确定用户是不是同一个用户，就需要靠unionid来区分。unionid如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性。同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。加锁的登录在某些情况下，我们或许多个地方会同时触发登录逻辑（如多个接口同时拉取，发现登录态过期的情况）。一般来说，我们会简单地给请求加个锁来解决：使用isLogining来标志是否请求中。方法返回 Promise，登录态过期时静默续期后重新发起。使用sessionId来记录业务侧的登录态。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// session 参数 key（后台吐回）export const SESSION_KEY = 'sessionId';let isLogining = false;export function doLogin() {  return new Promise((resolve, reject) => {    const session = wx.getStorageSync(SESSION_KEY);    if (session) {      // 缓存中有 session      resolve();    } else if (isLogining) {      // 正在登录中，请求轮询稍后，避免重复调用登录接口      setTimeout(() => {        doLogin()          .then(res => {            resolve(res);          })          .catch(err => {            reject(err);          });      }, 500);    } else {      isLogining = true;      wx.login({        success: (res) => {          if (res.code) {            const reqData: ILoginRequest = {                code: res.code            }            wx.request({              url: API.login,              data: reqData,              // method: \"POST\",              success: (resp) => {                const data = resp.data;                isLogining = false;                // 保存登录态                if (data.return_code === 0) {                  wx.setStorageSync(SESSION_KEY, data[SESSION_KEY]);                  resolve();                } else {                  reject(data.return_msg);                }              },              fail: err => {                // 登录失败，解除锁，防止死锁                isLogining = false;                reject(err);              }            });          } else {            // 登录失败，解除锁，防止死锁            isLogining = false;            reject();          }        },        fail: (err) => {          // 登录失败，解除锁，防止死锁          isLogining = false;          reject(err);        }      });    }  });}登录态静默续期的实现checkSession前面也提到，微信不会把session_key的有效期告知开发者，因此需要使用接口wx.checkSession()来校验session_key是否有效。这里我们：使用isCheckingSession来标志是否查询中。返回 Promise。使用isSessionFresh来标志session_key是否有效。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import { doLogin } from \"./doLogin\";import { SESSION_KEY } from \"./doLogin\";let isCheckingSession = false;let isSessionFresh = false;export function checkSession(): Promise<string> {  return new Promise((resolve, reject) => {    const session = wx.getStorageSync(SESSION_KEY);    if (isCheckingSession) {      setTimeout(() => {        checkSession()          .then(res => {            resolve(res);          })          .catch(err => {            reject(err);          });      }, 500);    } else if (!isSessionFresh && session) {      isCheckingSession = true;      wx.checkSession({        success: () => {          // session_key 未过期，并且在本生命周期一直有效          isSessionFresh = true;          resolve();        },        fail: () => {          // session_key 已经失效，需要重新执行登录流程          wx.removeStorage({            key: \"skey\",            complete: () => {              doLogin()                .then(() => {                  resolve();                })                .catch(err => {                  reject(err);                });            }          });        },        complete: () => {          isCheckingSession = false;        }      });    } else {      doLogin()        .then(res => {          resolve(res);        })        .catch(err => {          reject(err);        });    }  });}静默续期的接口请求至此，我们可以封装一个简单的接口，来在每次登录态过期的时候自动续期：在请求前，使用checkSession()检车本次周期内session_key是否有效，无效则doLogin()拉起登录获取sessionId。请求接口，若返回特定登录态失效错误码（此处假设为LOGIN_FAIL_CODE），则doLogin()拉起登录获取sessionId。使用tryLoginCount来标志重试次数，TRY_LOGIN_LIMIT来标志重试次数上限，避免进入死循环。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { doLogin } from \"./doLogin\";import { SESSION_KEY } from \"./doLogin\";import { checkSession } from \"./checkSession\";// 会话过期错误码，需要重新登录export const LOGIN_FAIL_CODES = [10000];const TRY_LOGIN_LIMIT = 3;export function request(obj: any = {}): Promise<object> {  return new Promise((resolve, reject) => {    checkSession()      .then(() => {        let session = wx.getStorageSync(SESSION_KEY);        const { url, data, method, header, dataType } = obj;        let tryLoginCount = obj.tryLoginCount || 0;        // 如果需要通过 data 把登录态 sessionId 带上        const dataWithSession = { ...data, [SESSION_KEY]: session, appid: APPID };        wx.request({          url,          data: dataWithSession,          method,          header,          dataType,          success: (res: any) => {            if (res.statusCode === 200) {              const data: ICommonResponse = res.data;              // 登陆态失效特定错误码判断，且重试次数未达到上限              if (LOGIN_FAIL_CODES.indexOf(data.return_code) > -1 && tryLoginCount < TRY_LOGIN_LIMIT) {                doLogin().then(() => {                  obj.tryLoginCount = ++tryLoginCount;                  request(obj)                    .then(res => {                      resolve(res);                    })                    .catch(err => {                      reject(err);                    });                });              } else {                resolve(res);              }            } else {              reject(res);            }          },          fail: function(err) {            reject(err);          }        });      })      .catch(err => {        reject(err);      });  });}至此，我们大概包装了一个能自动登录或是进行静默续期的一个请求接口。参考小程序登录API《小程序开发指南》结束语小程序的登录和登录态管理，大概是大部分小程序都需要的能力。code和session_key的设计，做了哪些事情来保护用户的数据。如何在全局范围地保证登录态的有效性，微信侧的登录态也好，业务侧的登录态也好，静默续期的能力能给用户带来不少的体验提升。查看Github有更多内容噢：https://github.com/godbasin"}
{"title": "微信小程序获取用户的 OpenId （附前端代码）", "author": "Rolan", "pub_time": "2019-3-1 00:41", "content": "OpenId是什么？openid是表示用户在你的当前应用中的 唯一标识 ,比如小程序，微信公众号等，这些都算是一个应用，如果你有多个应用，同一个用户的openId可能并不相同**下图是获取OpenId的过程微信的官方文档和时序图****小程序登录的时序图**思路：首先调用wx.login({})获取登录凭证（code）调用接口前，需要把微信小程序的appid 和 secret 告知后端用拿到的code 换取 openid实例：App({\r\nonLaunch: function() {\r\n    var self = this;\r\n    // 展示本地存储能力\r\n    var logs = wx.getStorageSync('logs') || []\r\n    logs.unshift(Date.now())\r\n    wx.setStorageSync('logs', logs)\r\n\r\n/** 重点来了****************\r\n    |\r\n    |\r\n    |\r\n    |\r\n*********/\r\n    // 登录\r\n    wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        var Params = {\r\n          code: res.code, //临时登录凭证\r\n          key: self.globalData.MD5Key\r\n        };\r\n        //生成加密key\r\n        Params.key = self.MD5(Params.code + \"&\" + self.getNowTime() + \"&\" + Params.key);\r\n        wx.request({\r\n          url: 'https://testurl/api/test/GetOpenId', //此处填写第三方的接口地址\r\n          data: '=' + JSON.stringify(Params),\r\n          header: {\r\n            'content-type': 'application/json'\r\n          },\r\n          method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n          success: function(res) {\r\n            var openid = res.data.RntData.openid //返回openid\r\n            self.globalData.openid = openid;\r\n            console.log(openid);\r\n          }\r\n        })\r\n      }\r\n    })\r\n    /** 重点结束\r\n    |\r\n    |\r\n    |\r\n    |\r\n********************************/\r\n    // 获取用户信息\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          wx.getUserInfo({\r\n            success: res => {\r\n              // 可以将 res 发送给后台解码出 unionId\r\n              this.globalData.userInfo = res.userInfo\r\n\r\n              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\r\n              // 所以此处加入 callback 以防止这种情况\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  }\r\n}）是不是很好奇，为什么会多了一步，用第三方服务器去访问微信接口的过程呢？如果appid和secret存在本地或者前端直接去获取，很容易被抓包从而导致用户信息泄露，因此，用第三方服务器去请求微信接口，能确保openID的安全性。"}
{"title": "mpvue开发音频类小程序踩坑和建议", "author": "Rolan", "pub_time": "2019-3-12 00:15", "content": "这是我第一次开发小程序，开发的产品是音频类的，在大佬的建议下采用了 mpvue ,一周时间把功能都做出来，由于不太熟悉mpvue和微信小程序，足足用了一周时间来改bug才出来一个能用的版本，在这里整理分享下我开发时遇到的一些问题和给出一些建议。在 Linux 上开发小程序在公司电脑装了双系统，日常用的是 Ubuntu 系统，Linux或Mac的开发环境对前端相对来说会友好一些。微信小程序官方的开发者工具只有 Windows 和 Mac 版本，所以这就尴尬了。不过还好，发现已经有大神在GitHub上做了Linux的支持，推荐给大家： Linux微信web开发者工具 。 根据教程安装使用即可，使用时就用 ./bin/wxdt 命令打开。不过用了几天后面觉得不太方便，就索性切回Windows系统用官方最新的版本了。封装wx.request为Promisewx.request 用于发起http请求，但平时习惯了Promise的写法，所以还是封装一下这个方法为Promise的形式。 我看很多小程序会使用 fly 这个库。但个人觉得发起请求不需要那么强大的功能，小程序本身就应该是一个轻量级的东西，引入一个库可能会导致项目打包变大，可能让小程序更卡，所以本着能自己写就自己写吧的心态，索性自己封装一下算了。在 src/utils ,新建一个 request.js :const apiUrl = 'https://your server.com/api/'\r\nconst request = (apiName, reqData, isShowLoading = true) => {\r\n  // 某些请求可能不需要显示loading\r\n  if (isShowLoading) {\r\n    wx.showLoading({\r\n      title: '正在努力加载中',\r\n      mask: true\r\n    })\r\n  }\r\n\r\n  return new Promise(function (resolve, reject) {\r\n    wx.request({\r\n      url: apiUrl + apiName,\r\n      method: 'POST',\r\n      data: reqData,\r\n      header: {\r\n        'content-type': 'application/json' // 默认值\r\n      },\r\n      success (res) {\r\n        if (res.data.code === 0) {\r\n          // 与后端约定code=0时才是正常的\r\n          resolve(res)\r\n        } else {\r\n          reject(res)\r\n        }\r\n      },\r\n      fail (err) {\r\n        reject(err)\r\n      },\r\n      complete (res) {\r\n        wx.hideLoading()\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nexport default request\r\n复制代码当然这是个简化版的，我实际项目中还会在初始化时加入一些 token 之类的参数，大家能看明白是这样封装成Promise的就可以啦。使用vant-weapp小程序已经支持了npm安装，但不太会弄。还是按网上方法，将项目clone下来放进static目录下。git clone https://github.com/youzan/vant-weapp.git\r\n复制代码然后将 vant-weapp 的 dist 目录拷贝到项目的static目录下（尽可能精简，删掉一些奇奇怪怪的如 .github 的东西，所以直接使用dist目录），改名为 vant (也可以不改名)。全局使用时，可以在 app.json 引入：\"usingComponents\": {\r\n    \"van-button\": \"/static/vant/button/index\",\r\n    \"van-field\": \"/static/vant/field/index\"\r\n  },\r\n复制代码注意：需要打开微信开发者工具中的ES6转ES5功能一开始以为使用起来和web端的没啥差别，但没想到那么麻烦。比如：在vue中是可以使用 v-model 的，但在mpvue中的小程序中不能使用，只能<van-field :value=\"password\" type=\"password\" @change=\"pwdChange\" input-class=\"myClass\" />\r\n复制代码而且不能随意灵活添加class修改组件的样式，需要vant组件支持提供外部样式才可修改，比如上面的 van-field 是通过 input-class 来添加样式控制的，很不方便。而且某些内部样式由于没有外部样式表，根本改不了。综上： 在微信小程序使用第三方组件库不太方便，样式修改比较麻烦，如果产品是有UI设计时， 尽量不使用 ，有时候自己实现样式可能更快，而且项目体积更小。使用vuexmpvue官方的快速模板中是将vuex放在 counter 这个page目录下，可能习惯了vue官方写法的很多同学（包括我）不太喜欢，所以最好就改为vuex官方的写法。在src目录下建一个 store 的文件夹，分别建以下文件：项目不太复杂时不建议使用modules，使用起来比较麻烦。贴一下 index.js 的代码，其他的 actions.js , getters.js 按官方的写法就好啦。import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\nimport * as actions from './actions'\r\nimport * as getters from './getters'\r\nimport state from './state'\r\nimport mutations from './mutations'\r\nimport createLogger from 'vuex/dist/logger'\r\n\r\nVue.use(Vuex)\r\n\r\nconst debug = process.env.NODE_ENV !== 'production'\r\n\r\nexport default new Vuex.Store({\r\n  actions,\r\n  getters,\r\n  state,\r\n  mutations,\r\n  strict: debug,\r\n  plugins: debug ? [createLogger()] : []\r\n})\r\n\r\n复制代码vuex/dist/logger 是vuex在开发环境可以自动打印日志的工具，debug比较方便，建议使用。 然后在 src/main.js 引入：import Vue from 'vue'\r\nimport App from './App'\r\nimport store from '@/store'\r\n\r\nVue.config.productionTip = false\r\nApp.mpType = 'app'\r\n\r\nVue.prototype.$store = store\r\n\r\nconst app = new Vue({\r\n  store\r\n})\r\napp.$mount()\r\n复制代码这样就可以在项目中正常使用啦，完全支持 mapState , mapActions , mapGetters 的写法，比如在 pages/index/index.vue 中使用：<script>\r\nimport { mapState, mapActions } from 'vuex'\r\nexport default {\r\n  computed: {\r\n    ...mapState(['myAudio'])\r\n  },\r\n  methods: {\r\n    ...mapActions(['myActions'])\r\n  },\r\n  created () {\r\n    this.myActions() //调用vuex中的方法\r\n  }\r\n}\r\n</script>\r\n复制代码踩坑指南其实大多数坑可能是mpvue的，很多情况也是自己不熟悉小程序生命周期导致的一些奇奇怪怪的bug。mpvue是支持小程序原生组件的mpvue会将 div 编译为小程序中的 view 。一开始我不了解，以为用了mpvue后就不能使用小程序原生支持的组件了，比如 swiper , scroll-view 等，小程序是支持的，可以放心使用哈哈。npm run build后样式丢失本来在开发环境正常的，然后准备发版 npm run build 后发现样式丢失了。然后重新 npm start 排查问题，样式还是丢失的。内心此时是mmp的：npm run build丢失就算了，我没改什么东西重新npm start后为什么还是丢失，之前还是正常的呀？刚开始怀疑是缓存什么的问题，删掉的dist目录，重启开发者工具，甚至重启电脑都试了一下，这是我遇到的超级诡异的问题之一。冷静下来想到：之前的版本是正常的，一定是新版本引入了什么导致了打包样式的丢失。于是回滚版本一个个build排查问题，最后找到了原因： 在一个page中引入了其他page，即在页面中import另一个页面。在我这里的具体例子是：我在 pages/index/index.vue 中想做底部共用一个tabbar，页面根据tabbar的值来显示对应的子级页面: pages/page1/index.vue 和 pages/page2/index.vue 。所以我将这两个页面当做子组件来引入了： import Page1 from '@/pages/page1' ，一开始没有问题，等重启项目，或者build后就发现样式丢失了。这可能是mpvue打包机制的一个限制，即 页面不能将另一个页面当子组件来引用 ，否则会导致样式丢失。背景音频的src无法读取项目中希望用户退出小程序后依然能播放音频，所以用到了背景音频的api： wx.getBackgroundAudioManager()。this.audio = wx.getBackgroundAudioManager()\r\nthis.audio.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&fromtag=46' \r\nthis.audio.title = '此时此刻' //注意必填\r\nthis.audio.epname = '此时此刻'\r\nthis.audio.singer = '许巍'\r\nthis.audio.coverImgUrl = 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'\r\n复制代码title 和 src 赋值后会直接播放音频，后面的几个属性建议也填上，因为播放背景音频时微信是有个界面需要封面图和歌手名称等的。如果想要获取当前正在播放的音频src，本来以为通过 this.audio.src 来获取就可以了但是有bug。在开发者工具中是可以正常获取的，即开发时是没问题的，但在真机上返回的是 undefined ，因此不能用 this.audio.src 来获取当前播放的音频url，得用一个变量来存这个数据。直接使用音频的currentTime可能渲染不及时currentTime用于显示当前的播放进度，但我用在子组件中时经常更新不及时，打印是正常的，但试图渲染不及时，有时候需要点击一下才能重新渲染，这可能是mpvue使用时才会遇到。所以建议还是项目自身维护一套背景音频的变量比较好一点，比如放在 vuex 中。监听 BackgroundAudioManager.onTimeUpdate() 方法每次赋值到自身维护的变量中。音频的onCanplay方法不一定每个音频都会触发一开始我监听在 onCanplay 方法，将音频的时长信息 duration 赋值到vuex中存起来，但发现 onCanplay 有时候是不会触发的，比如重新赋值src播放下一首时，很尴尬。所以不要太依赖onCanplay这个方法，还好目前直接使用 audio.duration 好像不会出现像上面的 currentTime 渲染不及时的问题，所以就这样用着先。音频播放结束，即onStop后，不能再通过audio.play()的方法重新播放，得重新赋值src正常来说，音频播放结束后，音频的src是不变的，再次 play() 应该是可以的。但在小程序中偏偏不行，得重新赋值src才能重新播放，这应该是小程序的一个bug。。。所以需要判断一下 暂停 和 停止 的情况，用不同的办法播放。正常来说，音频暂停时 currentTime 是不为0的，而结束时 currentTime 会为0。所以可以通过 currentTime （最好是自己维护的变量）来判断暂停和停止的情况: 如果currentTime不为0，表示是暂停的情况，可以用 play() ,如果小于等于0，则重新赋值src播放 ：if (currentTime) {\r\n  this.audio.play()\r\n} else {\r\n  this.audio.src = 'xx.mp3'\r\n}\r\n\r\n复制代码mpvue不支持直接在template上直接绑定函数这个是mpvue文档上有写的，不过一开始并不是很理解，也踩坑了，所以在这里提一下，避免不知道的同学踩坑找半天。<template>\r\n  <div v-for=\"(item, index) in list\" :key=\"index\">{{ formatItem(item) }}</div>\r\n</template>\r\n \r\n<script>\r\nexport default {\r\n  data () {\r\n    return{\r\n      list: [1, 2, 3]\r\n    }\r\n  },\r\n  methods: {\r\n    formatItem (item) {\r\n      return `我是${item}`\r\n    }\r\n  }\r\n}\r\n</script>\r\n复制代码上面的代码应该是日常vue中比较常用的，就是将数据传参给方法做一些处理，这个在mpvue中是不支持的，会被编译成一个空字符串。小程序中可放心使用css3的一些特性比如高斯模糊filter: blur(50px);\r\n复制代码如果要使用动画，尽量用 css 动画代替 wx.createAnimation在实际使用时， wx.createAnimation 做动画其实很卡，性能很差，所以在需要使用动画时，建议尽量使用css做动画。在小程序中是支持css动画的， transition , animation , @keyframes 这些特性都支持。比如做一个div一直旋转的动画，大家可以对比一下两个版本：wx.createAnimation 版本原理：通过setInterval()不断更新div的旋转位置<template>\r\n  <div class=\"cover\" :animation=\"animationData\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      animationData: '',\r\n      animation: '',\r\n      rotateCount: 0,\r\n      timer: ''\r\n    }\r\n  },\r\n  components: {\r\n\r\n  },\r\n  methods: {\r\n     startRotate () {\r\n       this.timer = setInterval(() => {\r\n         this.rotateAni(++this.rotateCount)\r\n       }, 100)\r\n     },\r\n     rotateAni (n) {\r\n       if (!this.animation) {\r\n         return\r\n       }\r\n       // 每100毫秒旋转10度\r\n       this.animation.rotate(10 * n).step()\r\n       this.animationData = this.animation.export()\r\n     }\r\n  },\r\n  onShow () {\r\n     // 页面从隐藏到显示时才执行\r\n     if (!this.animation) {\r\n       this.animation = wx.createAnimation()\r\n       this.startRotate()\r\n     }\r\n  },\r\n  onReady () {\r\n     // 第一次初始化时会执行\r\n     if (!this.animation) {\r\n       this.animation = wx.createAnimation()\r\n       this.starRotate()\r\n     }\r\n  },\r\n  onHide () {\r\n    // 页面隐藏时会执行，避免频繁的setData操作，将定时器停掉\r\n    this.timer && clearInterval(this.timer)\r\n  },\r\n  beforeDestroy () {\r\n    // 页面卸载，也停掉定时器\r\n    this.timer && clearInterval(this.timer)\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n  .cover {\r\n    left: 20px;\r\n    bottom: 70px;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    position: absolute;\r\n    width: 50px;\r\n    height: 50px;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.2);\r\n    border: 1px solid rgba(255, 255, 255, 0.5);\r\n    overflow: hidden;\r\n    z-index: 10000;\r\n  }\r\n</style>\r\n复制代码使用css的 @keyframes 做旋转动画<template>\r\n  <div class=\"cover\" :style=\"coverStyle\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n}\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n  // 定义一个动画名为 rotate\r\n  @keyframes rotate {\r\n    0%,\r\n    100% {\r\n      transform: rotate(0deg);\r\n    }\r\n    100% {\r\n      transform: rotate(360deg);\r\n    }\r\n  }\r\n  .cover {\r\n    left: 20px;\r\n    bottom: 70px;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    position: absolute;\r\n    width: 50px;\r\n    height: 50px;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    box-shadow: 0px 2px 5px 0px rgba(0, 0, 0, 0.2);\r\n    border: 1px solid rgba(255, 255, 255, 0.5);\r\n    overflow: hidden;\r\n    z-index: 10000;\r\n    // 使用动画\r\n    animation: rotate 4s linear infinite;\r\n  }\r\n</style>\r\n复制代码用js写的动画需要控制好setInterval的间隔时间和旋转角度，比较难调。而用css写动画很简单，性能比js好，代码量也很少。使用css动画时建议开启硬件加速为了动画更流畅，想尽办法做优化，虽然不知道有没效果，反正用了再说[手动滑稽]。可以用will-change和 transform: translate3d(0,0,0) 开启硬件加速。我也不太会用，具体用法大家自行百度Google。will-change: auto;\r\ntransform: translate3d(0, 0, 0);\r\n复制代码iPhoneX需要底部导航条预留34px（68rpx）的高度。由于小程序中不能设置 viewport-fit=cover ，所以也就没有web中的安全区域说法，目前主流的做法是通过 wx.getSystemInfoSync() 判断是否是ipx，若是则给页面底部撑高34px。const res = wx.getSystemInfoSync()\r\nif (res.model.indexOf('iPhone X') >= 0) {\r\n  this.isIpx = true\r\n}\r\n复制代码注意是用 res.model.indexOf('iPhone X') ,在开发者工具的iPhone X中，model是全等于 iPhone X 的，但在真机中往往拿到的值是 iPhone X GZxxx ，即后面可能会带一串东西，所以用 indexOf 才是比较稳的，而且对 iPhone XR 等机型也适用。由于还有其他安卓机的全面屏，不太可能一一判断，而且某些安卓全面屏是没有用iPhone底部的工具条的（不存在冲突的情况），所以我们只判断iPhone X的情况就可以了，其他全面屏就不需要给底部预留了。至于全面屏布局的适配，需要用 flex 布局或者获取屏幕宽高来慢慢调了，建议最好用flex布局自适应处理。for循环中的子组件click事件无法触发Page -> 父组件 -> 子组件 ，在子组件click后 $emit 一个事件出来，发现无法触发。这个bug一开始没有出现，但偶然 npm run build 出现的，然后排查原因，后面即使回滚所有版本再npm start也还会出现。好像不触发则已，一发就不可收拾，这又是一个大坑，搜issue和加群问人，当晚下班回家研究到1点多都没有解决。第二天继续研究，感觉可能是框架的原因，最后尝试升级一下mpvue版本，没想到就正常了。直接使用quick-strat项目的 mpvue 版本是 2.0.0， mpvue 和 mpvue-template-compiler 升级到最新 2.0.6 就解决了。事后查看mpvue版本记录，果然是框架本身原因，并且找到了 issue 。npm run build后代码报错，再build一次可能报另一些错解决： 没找到原因，可能是引入vant导致的，打包时丢失了部分文件。多build几次，或者重启下小程序开发者工具就正常了。mpvue中created() 钩子会在页面初始化时全部一起触发，尽量不要用小程序生命周期的理解进入已销毁的page组件时依次触发: onLoad,onShow,onReady,beforeMount,mounted第一次进入已销毁的子组件时依次触发: onLoad,onReady,beforeMount,mounted第二次进入已销毁的子组件时依次触发: onLoad,onShow,onReady再次进入 未被销毁的page组件、子组件时只触发: onShowmpvue文档中建议尽量不要使用小程序的生命周期，这个应该是为了让项目更好地适应支付宝小程序和头条小程序等，所以才这样建议大家尽量不要使用某一个小程序自身的api。如果你们的小程序只是微信小程序（不考虑兼容其他平台小程序），我建议 直接用小程序的生命周期 ，而不要用mpvue的生命周期，坑太多了。比如mpvue的created周期，初始化时所有的page都会执行，所以created这个周期是不能用了。onUnload不触发小程序中与平常web开发不同的是，它的页面会被缓存。举个例子：从 page1 跳转到 page2 ，再从 page2 返回 page1 ,此时的 page1 还没销毁，不会触发 onLoad 再重新渲染，而是直接使用之前的数据。从性能上来说，单纯的返回不应该再请求api获取数据重新渲染，这是对的，符合我们的预期。而有时候，从 page2 返回 page1 时，我们希望 page1 是重新获取数据渲染的。比如在 page2 做了一个退出登录的操作，此时再返回 page1 时，还是会看到之前的数据。实际上我们的预期是：由于已经退出登录了， page1 的数据应该被销毁了。在平常的web开发中，遇到上面的问题，我们可能是不管缓存，每次返回 page1 都再次请求api渲染最新的数据，牺牲掉部分性能从而保证逻辑的正确性。在mpvue中我也尝试这样干了：想在 page1 的 onUnload() 生命周期中销毁数据，但是没有成功。即使在 page2 退出登录时，采用 wx.reLaunch() 重新刷一遍， page1 的 onUnload() 生命周期也没有执行。所以 onUnload() 是有可能不执行的，建议慎用。最后还是得想办法做到 在 page2 控制 page1 的数据销毁或保留 。想到这里， vuex 就不自觉浮现在眼前了，如果page1的数据是通过vuex来控制的，那么我在page2就可以用vuex来灵活管理其他页面的数据了。如果page2做退出登录操作时，就让page1的数据销毁，如果是不退出登录正常返回，page1的数据还是正常，做到灵活控制。个人平时web开发很少用 vuex ，因为项目比较简单不用那么复杂的全局数据传递。但在小程序中，建议全局使用 vuex 来控制所有数据（当然是得根据需求来用）。总结第一次开发小程序就直接上了mpvue，可能有些坑已经很多同学总结过了，有些坑可能是不熟悉而导致的，但自己没有去踩过一遍可能不够深刻。有两种坑会比较难啃：框架本身的问题，如mpvue2.0.0出现的子组件无法触发事件的问题。开发者工具和真机运行环境不一致导致的坑。遇到真机和开发者工具不一致的情况，可按以下步骤排查：wx.canIUse\r\nthis.audio.src\r\n而遇到mpvue框架的问题可以：mpvue\r\n希望对大家有所帮助。"}
{"title": "从App直接打开小程序", "author": "Rolan", "pub_time": "2019-3-21 00:23", "content": "今天无意中了解到APP竟然可以直接打开小程序这个功能，一致认为不可能啊，因为小程序是依靠微信，如果手机上微信没有打开，或者是没有安装微信会怎样呢？一起探索吧！步骤1.打开微信开发者平台文档,下载微信SDK。 2.根据文档手动集成SDK 3.点击进入小程序代码:    WXLaunchMiniProgramReq *launchMiniProgramReq = [WXLaunchMiniProgramReq object];    launchMiniProgramReq.userName = @\"gh_fc392b7c02cf\";  //拉起的小程序的原始ID    launchMiniProgramReq.path = @\"\";    //拉起小程序页面的可带参路径，不填默认拉起小程序首页    launchMiniProgramReq.miniProgramType = WXMiniProgramTypePreview; //拉起小程序的类型    [WXApi sendReq:launchMiniProgramReq];3.当小程序跳转app时，会走onReq的代理方法(文档中说的是onResp的方法,很坑)。需要把req强转成LaunchFromWXReq。其中WXMediaMessage下的messageExt才是小程序传给我们的参数。-(void)onResp:(BaseResp *)resp{    if ([resp isKindOfClass:[WXLaunchMiniProgramResp class]])    {        WXLaunchMiniProgramResp*rep = (WXLaunchMiniProgramResp*)resp;        NSString *string = rep.extMsg;        NSLog(@\"参数:%@\",string);    }}注意：1.查看移动端与小程序是否在同一开发者平台下（同一平台下直接跳转，不同平台下需要关联才能跳转）同一平台关联2.APP跳到小程序时报如下图：原因：因为APP暂未上架。 解决方案:我暂时选了一个上线的APP的Bundle id。APP跳到小程序时报如下图：原因：因为用的是体验版，所登的微信账号无体验权限。 解决方案:管理员给该账户体验权限，用该小程序有体验权限的账号测试。"}
{"title": "小程序自定义导航栏适配（完美版）", "author": "Rolan", "pub_time": "2019-4-2 00:27", "content": "1、发现问题小程序页面自定义导航栏功能已经开放有些日子了(还不知道这个功能的可以先 >>了解一下 )，这极大的提升了小程序开发的自由度，相信不少小伙伴已经使用过这个功能，同时也相信不少小伙伴在此功能开发过程中踩过同样的一些坑：机型多如牛毛：自定义导航栏高度在不同机型始终无法达到视觉上的统一；调皮的胶囊按钮：导航栏元素（文字，图标等）怎么也对不齐那该死的胶囊按钮；各种尺寸的全面屏，奇怪的刘海屏，简直要抓狂。同样的，这些问题也是小灰经历过的。但是小灰相信，办法总比问题多，于是开始了自己的探究：2、一探究竟为了搞明白到底该怎么去适配，老规矩，我先翻了一波官方文档，还别说，官方还真有这么一段介绍了相关细节， >>详情点击 ：从图中分析，我们可以得到如下信息：Android跟iOS有差异，表现在顶部到胶囊按钮之间的距离差了6pt胶囊按钮高度为32pt， iOS和Android一致这。。。，好像并没有什么L用啊？？这仅仅是普通屏幕为参照的，ipx， 安卓全面屏完全没介绍。沉着冷静，我们接着分析：胶囊按钮到状态栏下边缘这块距离，好像是固定的？安卓这个图，好像有点奇怪？导航栏分为 状态栏+标题栏？如果车两个条件成立，那我们的问题是不是就解决了80%了？那么我们来论证一下：第一个问题：胶囊按钮到状态栏下边缘的距离是不是固定的？很简单，我们写一个状态栏，通过wx.getSystemInfoSync().statusBarHeight设置高度为了好测量，我们设置状态栏背景色为深色js代码：var sysinfo = wx.getSystemInfoSync();\r\nthis.setData({ \r\n     statusBarHeight:sysinfo.statusBarHeight \r\n})wxml代码：<view class=\"status-bar\" style=\"height:{{statusBarHeight}}px\"></view>wxss代码：.status-bar{\r\n    background: rgb(141, 71, 71);\r\n }效果图（iPhone6）：效果图（iPhoneX）：效果图（安卓）：是不是有点眉目了？是的，从截图可以看出，iOS是一致的，但是Android好像有所差别。那究竟距离是多少？我们用神器（微信截图）来量一量：Android：iOS：可以看出，iOS胶囊按钮与状态栏之间距离为：6px， Android为8px，并且经过测量，iOS各机型，Android各机型结果一致（由于篇幅原因，就不一一展示截图了，有兴趣的可以自行测量）第二个问题：导航栏分为 状态栏+标题栏？通过对第一个问题的论证，很明显能看出来确实是这样的。并且通过第一个问题的测量结果以及官方提供的数据，我们可以对标题栏高度进行计算：导航栏高度 = 胶囊按钮高度 + 状态栏到胶囊按钮间距 * 2Android导航栏高度 = 32px + 8px * 2 = 48pxiOS导航栏高度 = 32px + 6px * 2 = 44px*注：由于胶囊按钮是原生组件，为表现一直，其单位在个系统都为px，所以我们的自定义导航栏各个高度的单位都必需是px（切记不能用rpx），才能完美适配。3、解决问题通过上述分析，相信小伙伴们都能有一个解决问题的思路了，在上代码之前，小灰再给大家画一下重点：写自定义导航组件的时候，需要将组件结构一分为二：状态栏 + 标题栏状态栏高度可通过wx.getSystemInfoSync().statusBarHeight获取标题栏高度：安卓：48px，iOS：44px单位必需跟胶囊按钮一致，用px话不多说，上代码( gitHub地址 )：js：Component({   \r\n   properties: {        \r\n    background: {            \r\n        type: String,            \r\n        value: 'rgba(255, 255, 255, 1)'        \r\n    },        \r\n    color: {            \r\n        type: String,            \r\n        value: 'rgba(0, 0, 0, 1)'        \r\n    },        \r\n    titleText: {            \r\n        type: String,            \r\n        value: '导航栏'        \r\n    },        \r\n    titleImg: {            \r\n        type: String,            \r\n        value: ''        \r\n    },        \r\n    backIcon: {            \r\n        type: String,            \r\n        value: ''        \r\n     },        \r\n    homeIcon: {            \r\n        type: String,            \r\n        value: ''        \r\n    },        \r\n    fontSize: {            \r\n        type: Number,            \r\n        value: 16        \r\n    },        \r\n    iconHeight: {            \r\n        type: Number,            \r\n        value: 19       \r\n    },        \r\n    iconWidth: {            \r\n        type:Number,            \r\n        value: 58        \r\n    }    \r\n   },    \r\nattached: function(){        \r\n   var that = this;        \r\n   that.setNavSize();        \r\n   that.setStyle();    \r\n},    \r\n data: {\r\n    },    \r\nmethods: {        \r\n// 通过获取系统信息计算导航栏高度        \r\nsetNavSize: function() {            \r\nvar that = this                \r\n    , sysinfo = wx.getSystemInfoSync()                \r\n    , statusHeight = sysinfo.statusBarHeight                \r\n    , isiOS = sysinfo.system.indexOf('iOS') > -1                \r\n    , navHeight;            \r\nif (!isiOS) {                \r\n    navHeight = 48;            \r\n   } else {                \r\n    navHeight = 44;            \r\n}            \r\nthat.setData({                \r\n    status: statusHeight,                \r\n    navHeight: navHeight            \r\n  })        \r\n},        \r\nsetStyle: function() {            \r\n    var that  = this                \r\n    , containerStyle                \r\n    , textStyle                \r\n    , iconStyle;            \r\n    containerStyle = [                \r\n        'background:' + that.data.background                \r\n        ].join(';');            \r\n        textStyle = [                \r\n        'color:' + that.data.color,                \r\n        'font-size:' + that.data.fontSize + 'px'            \r\n        ].join(';');            \r\n        iconStyle = [                \r\n        'width: ' + that.data.iconWidth + 'px',                \r\n        'height: ' + that.data.iconHeight + 'px'            \r\n        ].join(';');            \r\n        that.setData({               \r\n             containerStyle: containerStyle,                \r\n             textStyle: textStyle,                \r\n             iconStyle: iconStyle            \r\n        })        },        \r\n        // 返回事件        \r\nback: function(){            \r\n    wx.navigateBack({                \r\n        delta: 1            \r\n    })            \r\n    this.triggerEvent('back', {back: 1})        \r\n},        \r\nhome: function() {            \r\n    this.triggerEvent('home', {});       \r\n }   \r\n }})wxml：<view class='nav' style='height: {{status + navHeight}}px'>    \r\n    <view class='status' style='height: {{status}}px;{{containerStyle}}'></view>                               <view class='navbar' style='height:{{navHeight}}px;{{containerStyle}}'>        <view class='back-icon' wx:if=\"{{backIcon}}\" bindtap='back'>                    <image src='{{backIcon}}'></image>       \r\n         </view>        \r\n    <view class='home-icon' wx:if=\"{{homeIcon}}\" bindtap='home'>            \r\n        <image src='{{homeIcon}}'></image>        \r\n    </view>        [链接描述][10]\r\n    <view class='nav-icon' wx:if=\"{{titleImg}}\">            \r\n    <image src='{{titleImg}}' style='{{iconStyle}}'></image>       \r\n     </view>\r\n            <view class='nav-title' wx:if=\"{{titleText && !titleImg}}\">\r\n                <text style='{{textStyle}}'>{{titleText}}</text>\r\n            </view>\r\n        </view>\r\n    </view>wxss：.navbar{\r\n    position: relative\r\n}\r\n.back-icon, .home-icon{\r\n    width: 28px;\r\n    height: 100%;\r\n    position: absolute;    \r\n    transform: translateY(-50%);    \r\n    top: 50%;    \r\n    display: flex;\r\n    }\r\n.back-icon{    \r\n    left: 16px;\r\n}\r\n.home-icon{    \r\n    left: 44px\r\n}\r\n.back-icon image{    \r\n    width: 28px;    \r\n    height: 28px;    \r\n    margin: auto;\r\n}\r\n.home-icon image{    \r\n    width: 20px;    \r\n    height: 20px;    \r\n    margin: auto;\r\n}\r\n.nav-title, .nav-icon{    \r\n    position: absolute;    \r\n    transform: translate(-50%, -50%);    \r\n    left: 50%;    \r\n    top: 50%;    \r\n    font-size: 0;    \r\n    font-weight: bold;\r\n}运行效果图：文字标题：图片标题：4、总结经过小灰的一番论证以及实践经验，最终总结出以上最终解决方案，但希望对小伙伴们有所帮助，如果小伙伴们觉得有用，记得给颗star哦 --> 点我 ，后续还会更新其他组件。如果大家有更好的方案或者觉得小灰的方案有问题，欢迎大家留言。"}
{"title": "微信小程序更新：支持被无限量公众号关联，且无需管理员确认！ ...", "author": "Rolan", "pub_time": "2019-4-11 00:00", "content": "微信小程序又悄悄调整了关联规则。4月4日，微信团队在微信开发者社区发帖称，小程序关联公众号策略调整：如图，我们来划一下这次更新的重点：•公众号关联小程序无需小程序管理员确认；•小程序可被无限数量的公众号关联；目前，在公众号后台关联小程序时，已出现无需关联确认的提醒，输入小程序名字或ID点击下一步即可完成关联。少了需要管理员确认这一步骤，关联的流程也方便了许多。根据此前的规则， 一个小程序可关联最多500个公众号，一个月可以新增关联500次，现在规则变了后，小程序可以被无限量的公众号关联，对于小程序推广来说是一大利好。今年以来，微信小程序在不少细节部分做出了调整，给开发者带来不少惊喜。1月份，不用关联公众号也可以直接插入任意小程序。相比之前，要先让小程序关联公众号才可以在后台插入小程序的规则，现在只需要在搜索框输入小程序名称就可以直接插入实现跳转，着实方便了不少，也有了更多的运营可能。2月27日，程序灰度上线自主注销功能。据悉，该功能支持个人、组织类型的帐号进行自主注销，小程序管理员可通过后台对帐号进行自主注销操作，验证主体真实性后帐号将进入冻结期，待冻结期结束两天后，帐号昵称将自动释放。3月25日，小程序后台上线“小程序评测”功能，只要符合“性能、运营、用户”三个维度的标准，且通过人工审核，就能优先获得一些功能的内测权。4月2日，小程序管理后台新增页面收录设置的开关，开发者可根据业务需要进行设置。当小程序设置为“允许被收录”时，小程序页面将可能展示在微信搜索等多个公开场景中。2019微信小程序还会怎么变，你怎么看？"}
{"title": "快应用开发的一些问题及总结", "author": "Rolan", "pub_time": "2019-4-11 00:04", "content": "语法上像极了VUE和微信小程序的结合版。1、配置文件内没有小程序一样可直接配置程序的tab页。处理方法：写一个Main入口文件，使用tab组件引入对应的模块即可。2、Main入口文件编写完 发现新的问题，有几个tab页就会同时加载几个页面的文件，如果使用官方示例的懒加载，在切换时tab页其实是重新加载的，不能像vue一样去保存状态，主页面如果是加载静态数据的话，不太适合，每次都在刷新页面，经验比较少，暂时没找到合适的方案处理。3、通用样式支持较少，通过flex布局完成布局样式的处理，这三行样式设置用的挺多的display: flex;\r\n    flex-direction: column;\r\n    flex-wrap: wrap;4、证书生成后一定要保存好，面得提交审核时找不到之前的 重新生成一个又不一样了。5、不要给list组件上下文添加其他组件，如果需要的话，把需要添加的地方写到list子组件list-item内进行渲染。6、页面title，如果是跳转到webView页面，等待h5页面加载后titleBar才会进行替换，可以在点击进入的页面内穿参数到webView页面。7、background-color会在红米note3手机查看webView页面后，设置样式同时含有border-radius时也会导致background-color失效。暂时不不同时使用background-color、border-radius。技术人员说会在新的版本内处理这个兼容问题。"}
{"title": "微信小程序之自定义模态弹窗（带动画）实例", "author": "Rolan", "pub_time": "2019-4-11 00:48", "content": "1、基本需求。实现用户自定义弹框 带动画（动画可做参靠，个人要是觉得不好看可以自定义动画） 获取弹出框的内容，自定义事件获取 2、案例目录结构二、程序实现具体步骤1.弹框index.wxml代码<!--button--><view class=\"btn\" bindtap=\"powerDrawer\" data-statu=\"open\">来点我呀</view><!--mask--><view class=\"drawer_screen\" bindtap=\"powerDrawer\" data-statu=\"close\" wx:if=\"{{showModalStatus}}\"></view><!--content--><!--使用animation属性指定需要执行的动画--><view animation=\"{{animationData}}\" class=\"drawer_box\" wx:if=\"{{showModalStatus}}\">  <!--drawer content-->  <view class=\"drawer_title\">弹窗标题</view>  <view class=\"drawer_content\">    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"rName\" value=\"可自行定义内容\"></input>    </view>    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"mobile\" value=\"110\"></input>    </view>    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"phone\" value=\"拒绝伸手党\"></input>    </view>    <view class=\"top grid\">      <label class=\"title col-0\">标题</label>      <input class=\"input_base input_h30 col-1\" name=\"Email\" value=\"仅供学习使用\"></input>    </view>    <view class=\"top bottom grid\">      <label class=\"title col-0\">备注</label>      <input class=\"input_base input_h30 col-1\" name=\"bz\"></input>    </view>  </view>  <view class=\"btn_ok\" bindtap=\"powerDrawer\" data-statu=\"close\">确定</view></view>2.弹框index.wxss代码/*button*/.btn {  width: 80%;  padding: 20rpx 0;  border-radius: 10rpx;  text-align: center;  margin: 40rpx 10%;  background: #000;  color: #fff;}/*mask*/.drawer_screen {  width: 100%;  height: 100%;  position: fixed;  top: 0;  left: 0;  z-index: 1000;  background: #000;  opacity: 0.5;  overflow: hidden;}/*content*/.drawer_box {  width: 650rpx;  overflow: hidden;  position: fixed;  top: 50%;  left: 0;  z-index: 1001;  background: #FAFAFA;  margin: -150px 50rpx 0 50rpx;  border-radius: 3px;}.drawer_title{  padding:15px;  font: 20px \"microsoft yahei\";  text-align: center;}.drawer_content {  height: 210px;  overflow-y: scroll; /*超出父盒子高度可滚动*/}.btn_ok{  padding: 10px;  font: 20px \"microsoft yahei\";  text-align: center;  border-top: 1px solid #E8E8EA;  color: #3CC51F;}.top{    padding-top:8px;}.bottom {    padding-bottom:8px;}.title {    height: 30px;    line-height: 30px;    width: 160rpx;    text-align: center;    display: inline-block;    font: 300 28rpx/30px \"microsoft yahei\";}.input_base {    border: 2rpx solid #ccc;    padding-left: 10rpx;    margin-right: 50rpx;}.input_h30{    height: 30px;    line-height: 30px;}.input_h60{    height: 60px;}.input_view{    font: 12px \"microsoft yahei\";    background: #fff;    color:#000;    line-height: 30px;}input {    font: 12px \"microsoft yahei\";    background: #fff;    color:#000 ;}radio{    margin-right: 20px;}.grid { display: -webkit-box; display: box; }.col-0 {-webkit-box-flex:0;box-flex:0;}.col-1 {-webkit-box-flex:1;box-flex:1;}.fl { float: left;}.fr { float: right;}3.弹框index.js逻辑代码 a.动画部分的功能实现util: function(currentStatu){    /* 动画部分 */    // 第1步：创建动画实例    var animation = wx.createAnimation({      duration: 200,  //动画时长      timingFunction: \"linear\", //线性      delay: 0  //0则不延迟    });    // 第2步：这个动画实例赋给当前的动画实例    this.animation = animation;    // 第3步：执行第一组动画    animation.opacity(0).rotateX(-100).step();    // 第4步：导出动画对象赋给数据对象储存    this.setData({      animationData: animation.export()    })    // 第5步：设置定时器到指定时候后，执行第二组动画    setTimeout(function () {      // 执行第二组动画      animation.opacity(1).rotateX(0).step();      // 给数据对象储存的第一组动画，更替为执行完第二组动画的动画对象      this.setData({        animationData: animation      })      //关闭      if (currentStatu == \"close\") {        this.setData(          {            showModalStatus: false          }        );      }    }.bind(this), 200)    // 显示    if (currentStatu == \"open\") {      this.setData(        {          showModalStatus: true        }      );    }  }三、案例运行效果图"}
{"title": "使用 wx.getLocation() 获取用户位置并转化成真实描述文字", "author": "Rolan", "pub_time": "2019-4-12 00:10", "content": "解决问题：在小程序中获取用户的信息， 使用 wx.getLocation API, 在使用这个 API 之前需要首先设置用户授权.用户有可能在进入小程序的时候关闭了获取位置的权限， 当需要获取位置的时候要重新判断是否拥有权限。 如果没有权限需要再次提醒用户授权.wx.getLocation 接口返回的用户位置是经纬度形式的， 需要借助于 微信小程序JavaScript SDK 对返回的 latitude longitude 经纬度信息解析为 国家 省份 市 ... 的形式。设置用户授权小程序中部分接口是需要用户授权同意后才能调用的。 像 getUserInfo getLocation chooseAddress chooseInvoiceTitle getWeRunData 等。 当我们在小程序中需要使用这些接口的时候，首先都要用户用户授权才能使用， 我们可以使用 wx.openSetting 打开设置界面，引导用户开启授权。getLocation 除了需要用户授权外， 还需要在开发的时候在 app.json 配置地理位置用途说明;所以 第一步 我们需要在 app.json 文件中首先配置 地理位置用途说明app.json{\r\n    \"permission\": {\r\n        \"scope.userLocation\": {\r\n            \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n        }\r\n    }\r\n}\r\n复制代码获取经纬度信息第二步 在需要使用到 getLocation 接口的页面中的 xx.js 的 onLoad 方法中判断用户时候已经授权了 getLocation 的权限。使用 wx.getSetting 获取所有已授权接口。 该接口会返回一个 authSetting 对象， 里面包含了所有的授权结果。success(res) {\r\n   console.log(res.authSetting)\r\n   // res.authSetting = {\r\n   //   \"scope.userInfo\": true,\r\n   //   \"scope.userLocation\": true\r\n   // }\r\n }\r\n})\r\n复制代码所以我们可以在 onLoad 方法中使用 getSetting 方法判断用户是否授权了 userLocationonLoad: function() {\r\n    // 将当前页面的 this 赋值给 vm, 以区别于下面回调函数中的 this \r\n    const vm = this\r\n\r\n    wx.getSetting({\r\n      success(res) {\r\n        // 1. scope.userLocation 为真， 代表用户已经授权\r\n        if (res.authSetting['scope.userLocation']) {\r\n         // 1.1 使用 getlocation 获取用户 经纬度位置\r\n         wx.getLocation({\r\n             success(res){\r\n                 // 1.2 获取用户位置成功后，将会返回 latitude, longitude 两个字段，代表用户的经纬度位置\r\n                 console.log(res)\r\n\r\n                 // 1.3 将获取到的 经纬度传值给 getAddress 解析出 具体的地址\r\n                vm.getAddress(res.latitude, res.longitude)\r\n             }\r\n         })\r\n        }else {\r\n            // 2. 用户未授权的情况下， 打开授权界面， 引导用户授权.\r\n            wx.openSetting({\r\n                success(res) {\r\n                    // 2.1 如果二次授权允许了 userLocation 权限， 就再次执行获取位置的接口\r\n                    if (res.authSetting[\"scope.userLocation\"]) {\r\n                         wx.getLocation({\r\n                            success(res){\r\n                                // 2.2 获取用户位置成功后，将会返回 latitude, longitude 两个字段，代表用户的经纬度位置\r\n                                console.log(res)\r\n\r\n                                // 2.3 将获取到的 经纬度传值给 getAddress 解析出 具体的地址\r\n                                vm.getAddress(res.latitude, res.longitude)\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            })\r\n        }\r\n      }\r\n    })\r\n}\r\n\r\n复制代码上面的代码的逻辑是: 当页面加载完成后， 1. 先获取用户授权列表。 并判断是否有 scope.userLocation 的权限.如果有权限， 直接调用 wx.getLocation 获取用户的位置。 将获取的经纬度位置传递给 getAddress 。 在 getAddress 方法中将会把 经纬度位置转换成实际的 国家 省份 市 格式的地址；如果没有权限，就使用 wx.openSetting 接口代开权限设置界面， 让用户进行二次授权。授权成功后执行 wx.getLocation --> getAddress 的方法。注意 注意 注意： wx.openSetting 接口在 2018年10月1号起用法已经改变， 像代码中直接使用 wx.openSetting 来打开授权页面已经不能使用了， 新版本的使用方法参考 打开小程序设置页（wx.openSetting）接口调整转化经纬度信息为 国家 省份 市在第二步， 已经拿到了经纬度的信息之后， 使用了一个 getAddress 的方法，来转化经纬度。在这个方法中需要使用 微信小程序JavaScript SDK 来作为工具。在使用 微信小程序JavaScript SDK 的时候需要先在 微信小程序JavaScript SDK 中注册账号， 并申请一个 key , 要想在小程序中使用这个 key 还需要 把这个 key 的 WebServiceAPI 勾选上使用 '微信小程序 JavaScriptSDK' 需要 下载微信小程序 JavaScriptSDK v1.2 文件 。 然后将微信小程序 JavaScriptSDK 文件引入到当前页面的 xx.js 中。// xx.js\r\nconst QQMapWX = require('../../utils/qqmap-wx-jssdk.js')\r\n复制代码最后实现 getAddress 方法:getAddress(latitude, longitude) {\r\n        // 生成 QQMapWX 实例\r\n        let qqmapsdk = new QQMapWX({\r\n            key: 'xxxx-xxxxx-xxxxx-xxxxx-xxxxx-xxxxx-xxxxx'\r\n        })\r\n\r\n        // reverseGeocoder 为 QQMapWX 解析 经纬度的方法\r\n        qqmapsdk.reverseGeocoder({\r\n            location: {latitude,longitude},\r\n            success(res) {\r\n                console.log('success', res)\r\n                vm.setData({\r\n                    // ad_info: res.result.ad_info\r\n                    // city： res.result.ad_info\r\n                })\r\n            }\r\n        })\r\n    }\r\n复制代码关于 reverseGeocoder 返回的详细信息可以查看 reverseGeocoder 返回信息"}
{"title": "微信小程序：如何防止数据重复插入？", "author": "Rolan", "pub_time": "2019-4-12 00:23", "content": "号外：为读者持续整理了几份最新教程，覆盖了 Spring Boot、Spring Cloud、微服务架构等PDF。获取方式：关注右侧公众号\"泥瓦匠BYSocket\"，来领取吧！摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！目录为啥要解决数据重复插入？解决方案实战可落地小总结一、为啥要解决数据重复插入？问题起源，微信小程序抽风 wx.request() 重复请求服务器提交数据。后端服务也很简单，伪代码如下：class SignLogService {\r\n    public void saveSignLog(SignLogDO log) {\r\n        // 简单插入做记录\r\n        SignLogDAO.insert(log);\r\n    }\r\n}发现数据库会存在重复数据行，提交时间一模一样。但业务需求是不能有多余的 log 出现，这明显是个问题。问题是，重复请求导致的数据重复插入。这问题造成的后果很明显：数据冗余，可能不单单多一条有些业务需求不能有多余数据，造成服务问题问题如图所示：解决方式：如何将 同请求 A，不执行插入，而是读取前一个请求插入的数据并返回。解决后流程应该如下：二、解决方案实战1.单库单表解决方案唯一索引 + 唯一字段幂等上面说的那种业务场景：sign_log 表会有 user_id、sign_id、sign_time 等。那么每次签到，每个人每天只有一条签到记录。数据库层采取唯一索引的形式，保证数据记录唯一性。即 UNIQUE 约束，UNIQUE 约束唯一标识数据库表中的每条记录。另外，user_id,sign_id,sign_time 三个组合适唯一字段。创表的伪代码如下：CREATE TABLE sign_log\r\n(\r\nid int NOT NULL,\r\nuser_id int NOT NULL,\r\nsign_id int,\r\nsign_time int,\r\nCONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)\r\n)重点是 CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time) 。有个小问题，数据量大的时候，每条记录都会有对应的唯一索引，比较耗资源。那么这样就行了吗？答案是不行，服务不够健壮。第一个请求插入成功，第二个请求直接报错，Java 服务会抛出 DuplicateKeyException 。简单的幂等写法操作即可，伪代码如下：class SignLogService {\r\n    public SingLogDO saveSignLog(SignLogDO log) {\r\n        // 幂等处理\r\n        SignLogDO insertLog = null;\r\n        try {\r\n            insertLog = signLogDAO.insert(log);\r\n        } catch (DuplicateKeyException e) {\r\n            insertLog = selectByUniqueKeys(userId,signId,signTime);\r\n        }\r\n\r\n        return insertLog;\r\n    }\r\n}的确，流量不是很大，也不算很高并发。重复写问题，这样处理即可。那大流量、高并发场景咋搞2.分库分表解决方案流量大了后，单库单表会演变成分库分表。那么基于单表的唯一索引形式，在碰到分表就无法保证呢，插入的地方可能是两个分表 A1 和 A2。解决思路：将数据的唯一性条件放到其他存储，并进行锁控制还是上面的例子，每天，每次签到，每个人只有一条签到记录。那么使用分布式锁 Redis 的解决方案。大致伪代码如下：a.加锁// 加锁\r\njedis.set(lockKey, requestId, \"NX\", \"PX\", expireTime);lockKey 最简单的是 user_id + sign_id + sign_timeexpireTime 设置为一天b.解锁// 解锁\r\njedis.eval(script, lockKey,requestId);c.幂等代码加强class SignLogService {\r\n    public SingLogDO saveSignLog(SignLogDO log) {\r\n\r\n        // 幂等校验\r\n        SignLogDO existLog = selectByUniqueKeys(userId,signId,signTime);\r\n        if(Objects.nonNull(existLog)) {\r\n            return existLog;\r\n        }\r\n\r\n        // 加锁\r\n        jedis.set\r\n\r\n        SignLogDO insertLog = signLogDAO.insert(log);\r\n\r\n        // 解锁\r\n        jedis.eval\r\n\r\n        return insertLog;\r\n    }\r\n}这个方案还是不是很成熟，大家参考下即可。三、可落地小总结解决方案实战中，了解具体术。归纳如下：幂等：保证多次同意请求后结果一致并发控制：单表唯一索引、分布式多表分布式锁降级兜底方案：分布式锁锁失效 – 考虑乐观锁兜底"}
{"title": "支付宝小程序微信小程序分享转发", "author": "Rolan", "pub_time": "2019-4-12 00:42", "content": "由于业务需求最近对支付宝小程序和微信小程序的分享功能做了一些了解和尝试，进而写撰写此文作为积累和总结。\r\n微信小程序\r\n微信小程序触发分享有两种方式设置onShareAppMessage和button添加open-type=\"share\"属性\r\n微信 onShareAppMessage\r\n在page中添加onShareAppMessage方法，然后点击右上角菜单就会有分享选项，如果没有定义onShareAppMessage右上角菜单就没有分享选项\r\n微信自定义转发内容\r\n\r\n使用默认截图\r\n1.5.0\r\n\r\n\r\n\r\n代码示意\r\npage({\r\n  data: {\r\n    shareData: {\r\n      title: '自定义转发标题',\r\n      imageUrl: 'xxxx.jpeg',\r\n      path: '/page/API/pages/share/share'\r\n    }\r\n  },\r\n\r\n  onShareAppMessage() {\r\n    return this.data.shareData\r\n  }\r\n})\r\n复制代码转发方式\r\n转发方式只能转发给朋友或者群聊效果如下\r\n\r\n微信动态生成带有用户标识的自定义分享图片\r\n只是单纯的将固定图片分享到群聊显然不够酷炫，现在另一个比较流行的做法是生成一个自定义的分享图片，但是这个流程已经脱离了小程原本的分享功能。\r\n该流程的大体思路是用户触发自定义的分享按钮，然后再小程序端用canvas动态的绘制一个带有当前用户标识的图片存储到用户的相册中，之后用户在手动的将图片转发到朋友圈\r\n微信 open-type=\"share\"\r\nbutton组件设置open-type=\"share\"点击button触发分享，open-type=\"share\"模式如果没有定义onShareAppMessage方法也会触发分享\r\n支付宝\r\n支付宝小程序触发分享的方式跟微信小程序相同也是两种方式设置onShareAppMessage和button添加open-type=\"share\"属性\r\n支付宝onShareAppMessage\r\n在page中添加onShareAppMessage方法，然后点击右上角菜单就会有分享选项，如果没有定义onShareAppMessage右上角菜单也有分享选项\r\n支付宝自定义转发内容\r\n\r\n\r\n\r\n字段\r\n类型\r\n必填\r\n描述\r\n最低版本\r\n\r\n\r\n\r\n\r\ntitle\r\nString\r\n是\r\n自定义分享标题\r\n无\r\n\r\n\r\ndesc\r\nString\r\n否\r\n自定义分享描述：由于分享到微博只支持最大长度 140 个字，因此建议长度不要超过该限制。\r\n无\r\n\r\n\r\npath\r\nString\r\n是\r\n自定义分享页面的路径，path中的自定义参数可在小程序生命周期的 onLoad方法中获取（参数传递遵循 http get 的传参规则）\r\n无\r\n\r\n\r\ncontent\r\nString\r\n否\r\n自定义吱口令文案，最多28个字符实际测试无效，咨询支付宝运营人员说是文字吱口令下线了\r\n1.7.0\r\n\r\n\r\nimageUrl\r\nString\r\n否\r\n自定义分享小图 icon 元素，支持：网络图片路径；apFilePath 路径；相对路径。使用场景详见下方说明\r\n1.4.0\r\n\r\n\r\nbgImgUrl\r\nString\r\n否\r\n自定义分享预览大图，建议尺寸750x825，支持：网络图片路径；apFilePath路径（客户端10.1.58版本开始支持）；相对路径\r\n（客户端 10.1.58 版本开始支持\r\n\r\n\r\nsuccess\r\nFunction\r\n否\r\n分享成功后回调\r\n1.4.0\r\n\r\n\r\nfail\r\nFunction\r\n否\r\n分享失败后回调\r\n1.4.0\r\n\r\n\r\n\r\n支付宝转发方式\r\n支付宝转发方式花样就比较多了详情可以参考官方文档\r\n这里单单提一下分享到微信，当用户点击微信的时候支付宝会自动将分享图片存入用户相册（此时支付宝还有文案提示告诉你生成了吱口令去微信粘贴但是现在并不好使，咨询运营人员才知道吱口令下线了）\r\n\r\n关于动态生成带有用户标识的自定义分享图片的尝试\r\n因为支付宝分享会自动截屏保存到相册中，所以当时思考了一下如果当拉起分享窗口的时候页面通过显隐控制的方式，将原本的页面隐藏将规划好的个性化分享页面显示出来，然后小程序进行截图保存，这样既能生成带有用户标识的分享图片，还能无缝衔接到分享流程中，说干就干一顿操作之后在Android手机中测试完美几乎完美，可以天不遂人愿在IOS下失败了故放弃此方案。\r\n总结\r\n\r\n支付宝小程序和微信小程序分享API基本相同只是一些细节不太一样，最大的区别就是微信只能分享到群组或者好友，而支付宝提供了更多的方式\r\n遇见问题简单查查文档如果找不到头绪首选求助小程序交流群或者运营人员，因为小程序发展太快了有些问题能找到的资源并不多，而且官方文档更新的也不怎么及时，闷头踩坑的话有些得不偿失。\r\n信息具有实效性本文或者网上的其他文章或者官方文档皆不可全信一切以实践为准"}
{"title": "[博客小程序]评论通知功能实现(一)——小程序发送模板消息的几种实现 ...", "author": "Rolan", "pub_time": "2019-4-15 00:06", "content": "这两天抽空把评论通知的功能给基本实现了，主要解决读者评论后，我无法及时看到并回复的痛点。这篇主要说说模板消息发送的坑。使用前准备准备的话就是先读下文档，了解下模板消息怎么发送和怎么接入的，然后到你的后台去选择你想要的消息模板，记录好对应的模板ID即可。最初看文档的时候感觉挺简单的，无非先调用个接口获取 ACCESS_TOKEN , 然后调用发送模板消息的接口就完事了，当然事实也确实如此，但其中还是有些小坑的。后端实现后端实现对于我来说最轻松，毕竟是搞后端开发的嘛，我用 .net core 的方式实现了一把，轻松搞定，贴下代码，至于 java 或者 php ,其实差不多。/// <summary>\r\n/// 获取新的 AccessToken\r\n/// </summary>\r\n/// <returns></returns>\r\npublic static async Task<string> GetAccessToken()\r\n{\r\n    var url = $\"{WechatApiHost}/cgi-bin/token\";\r\n    var response = await HttpRequestHelper.GetAsync<dynamic>(url, new\r\n    {\r\n        grant_type = \"client_credential\",\r\n        appid = WechatAppId,\r\n        secret = WechatSecret\r\n    }, null, GlobalRequestConfig);\r\n    return response.IsSucceed && response.Data != null ? response.Data.access_token : null;\r\n}\r\n\r\n/// <summary>\r\n/// 发送模板消息\r\n/// </summary>\r\n/// <returns>The template message.</returns>\r\n/// <param name=\"openId\">Open identifier.</param>\r\npublic static async Task<ResponseResult> sendTemplateMessage(String openId)\r\n{\r\n    //先从redis获取token\r\n    var accessToken = await RedisInstance.Get<string>(MiniAccessTokenRedisKey);\r\n    if(string.IsNullOrWhiteSpace(accessToken))\r\n    {\r\n        accessToken =await GetNewAccessToken();\r\n        if (string.IsNullOrWhiteSpace(accessToken))\r\n            return new ResponseResult { Result = false, ErrorMessage = \"token获取失败\", Code = ResponseCode.InvalidParameters };\r\n        //保存到redis，默认1小时\r\n        await RedisInstance.Set<string>(MiniAccessTokenRedisKey, accessToken, 1 * 60 * 60);\r\n    }\r\n    var url = $\"{WechatApiHost}/cgi-bin/message/wxopen/template/send?access_token={accessToken}\";\r\n    var tempData = new\r\n    {\r\n        touser = openId,\r\n        template_id = MiniMessageTemplate,//申请的模板消息id，\r\n        page = \"/pages/detail/detail?blog=1\",\r\n        form_id = FormId,\r\n        data = new\r\n        {\r\n            keyword1 = new\r\n            {\r\n                value = \"元素1\"\r\n            },\r\n            keyword2 = new\r\n            {\r\n                value = \"元素2\"\r\n            },\r\n            keyword3 = new\r\n            {\r\n                value = \"元素3\"\r\n            }\r\n        },\r\n        //emphasis_keyword= \"keyword1.DATA\"\r\n    };\r\n    var response = await HttpRequestHelper.PostAsync<dynamic>(url, tempData, null, GlobalRequestConfig);\r\n    var sendResult = \"\";\r\n    if (!response.IsSucceed)\r\n        return new ResponseResult { Result = false, ErrorMessage = response.ErrorMessage, Code = ResponseCode.UnknownException };\r\n\r\n    return new ResponseResult { Result = true, ErrorMessage = \"\", Code = ResponseCode.Success };\r\n}js实现js的实现方式和后端代码实现也差不多，也是调用两个接口，逻辑一致，这里主要介绍util函数，避免重复造轮子。#github地址\r\nhttps://github.com/lcxfs1991/wx-js-utils对应的微信开放平台接口都基本已经封装好了，文档也比较详细，有兴趣的可以自己体验下。云调用实现这才是我想要的，本身我的博客小程序部分功能是基于云开发的，同时云调用实现的方式省去了获取 ACCESS_TOKEN 的步骤，使用起来比较方便。具体实现文档还是比较详细的，在使用前一定要在你的云函数目录下添加 config.json 文件，声明好所需调用的接口，并上传到云端。#声明使用发送模板消息接口\r\n{\r\n  \"permissions\": {\r\n    \"openapi\": [\"templateMessage.send\"]\r\n  }\r\n}这样就可以正常使用啦，贴下我的发送模板消息的代码：const sendResult = await cloud.openapi.templateMessage.send({\r\n    touser: touser,\r\n    templateId: template,\r\n    formId: form_id,\r\n    page: 'pages/detail/detail?blogId=' + event.blogId,\r\n    data: {\r\n      keyword1: {\r\n        value: event.nickName // keyword1 的值\r\n      },\r\n      keyword2: {\r\n        value: event.message // keyword2 的值\r\n      }\r\n    },\r\n  })本以为一切顺利，但终究好事多磨，上传到云端之后一直提示:function has no permission to call this API首先怀疑我的 config.json 没有上传上去，通过云开发后台去下载对应的函数，发现已经上传，同时也确定配置没有问题。再次仔细看文档，看到这样一句话：版本要求：wx-server-sdk >= 0.4.0、开发者工具 >= 1.02.1903251 （ 目前需开发版或测试版）于是尝试下载了开发版，重新上传了云函数，问题解决了「泪奔中」所以有使用云调用实现的小伙伴一定要注意自己的开发中工具。其他使用 ACCESS_TOKEN 的时候一定要注意，建议使用统一的服务来获取和刷新 access_token，其他业务逻辑所使用的 access_token 均来自于该服务，不应该各自去刷新，否则容易造成冲突，导致 access_token 覆盖而影响业务。另外开发版工具支持本地调试云函数了，同时云开发的管理界面也有很大改动，有兴趣的可以尝试下载看看。最后，下一篇文章讲讲我的博客小程序中评论通知功能的具体实现。"}
{"title": "[博客小程序]评论通知功能实现(二)——实战过程中的坑", "author": "Rolan", "pub_time": "2019-4-15 00:22", "content": "上一篇 小程序发送模板消息的几种实现 主要介绍了实现评论通知功能最重要的一环，这篇文章主要介绍实现该功能的具体实战。实现流程思路其实很简单，简单画了个流程图如下：这里有两个比较坑的地方，一个是微信本身发送模板消息的限制：当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）另外一个就是管理员如何初始化自己的formId的问题，而且自身的formId需求量比较大，读者评论完之后就要向管理员推送消息。所以无奈，增加了一个后台配置的功能，定期手动触发去生成自己的FormId「自动不行，只能手动，泪奔中」另外补充下，网上说的通过嵌套穿透的方式无限获取formId的方式已经行不通了，生成出来的formId都是一样的。评论提交收集FormId首先我们需要收集用户的 FormId ,有FormId才能发送对应的模板消息，在表单标签上加上 report-submit 属性即可。<form catchsubmit=\"formSubmit\" report-submit=\"true\">这样我们在提交评论表单的时候会获取到对应的 FormId , 我们将这个FormId保存至我们的云函数中。//评论提交按钮部分代码\r\nconsole.info(e.detail.formId)\r\nif (e.detail != undefined && e.detail.formId != undefined) {\r\n    var data = {\r\n        formId: e.detail.formId,\r\n        author: 0,\r\n        timestamp: new Date().getTime()\r\n      }\r\n    wxApi.insertFormIds(data).then(res => {\r\n        console.info(res)\r\n      })\r\n    }\r\n    \r\n//调用云数据库\r\nfunction insertFormIds(data) {\r\n  return db.collection('openid_formids').add({\r\n    data: data\r\n  })\r\n}这样管理员在接收到评论之后回复时就可以到 openid_formids 的集合中找到对应的formId来进行评论回复的模板消息推送了。管理员生成FormId为了让管理员能有更多的 FormId 来接收评论通知，因此我在小程序中搭建了个生成FormId的小页面。这样偶尔登录自己的小程序，查看下自己FormId的使用情况，若没有了可以手动生成几个。当然，这里会有一个权限问题，理论上这个页面只有管理员才可以展示，而其他人是没有权限访问的，因此需要提供个验证权限的云函数。这里可以使用云函数的环境变量来简单做个验证，将你的管理员的openId配置在环境变量中，云函数验证下openId是否一致即可。云函数代码如下，这样代码中不会存放敏感信息，开源的代码上传 github 也不会泄露。/**\r\n * 验证\r\n * @param {} event \r\n */\r\nasync function checkAuthor(event) {\r\n  if (event.userInfo.openId == process.env.author) {\r\n    return true;\r\n  }\r\n  return false;\r\n}发送模板消息最后就是发送模板消息的实现了，方法在上一篇说的比较具体了，基于我的博客小程序，使用云调用是最方便的。主要逻辑是根据传入的openId（如果为空默认取管理员的openId）到云数据库中取对应的formId。然后基于openId和formId发送相应的模板消息，发送后从云数据库中移除「发送一次后FormId就已经失效了」具体代码实现如下：/**\r\n * 发送通知消息\r\n * @param  event \r\n */\r\nasync function sendTemplateMessage(event) {\r\n\r\n  var touser = \"\";\r\n  var form_id = \"\";\r\n  var openId = event.tOpenId == \"\" ? process.env.author : event.tOpenId\r\n\r\n  //1.获取formId\r\n  var openIdformIds = await db.collection('openid_formids').where({\r\n    _openid: openId\r\n  }).limit(1).get()\r\n  if (openIdformIds.code) {\r\n    return;\r\n  }\r\n  if (!openIdformIds.data.length) {\r\n    return;\r\n  }\r\n  touser = openIdformIds.data[0]['_openid']\r\n  form_id = openIdformIds.data[0]['formId']\r\n\r\n  //2.取到后从云数据库中移除\r\n  const removeResult = await db.collection('openid_formids').doc(openIdformIds.data[0]['_id']).remove()\r\n  console.info(event.nickName + \":\" + event.message)\r\n  \r\n  //3.发送模板消息\r\n  const sendResult = await cloud.openapi.templateMessage.send({\r\n    touser: touser,\r\n    templateId: template,\r\n    formId: form_id,\r\n    page: 'pages/detail/detail?blogId=' + event.blogId,\r\n    data: {\r\n      keyword1: {\r\n        value: event.nickName // keyword1 的值\r\n      },\r\n      keyword2: {\r\n        value: event.message // keyword2 的值\r\n      }\r\n    },\r\n  })\r\n  return sendResult\r\n}到这里，具体实现流程就介绍完了，过程中还是会遇到些编码问题「主要还是对前端不是很熟悉，基本功问题」总结虽然功能基本实现，也已经上线了，但其实还是有一些细节问题的。比如通知消息点进去之后应该自动转到对应的评论区域，formId过期需要定时清理，管理员FormId需要通知管理员等，可以利用小程序的定时触发器等功能慢慢优化，后期优化后再来写文章总结。"}
{"title": "小程序 template 模版使用方法", "author": "Rolan", "pub_time": "2019-4-15 00:36", "content": "小程序开发语言虽然只能运行在微信小程序中， 但是它的设计同样遵循了主流前端框架的主要特征——组件化，在小程序中组件化的实现有两种方式: template 模版 和 Component 组件 。 这两种方式分别适用于不同的场景。template 模版 主要用于展示，模版中不涉及事件处理， 需要处理的事件逻辑放在调用模版的页面中。 一个 template 模版 只包含 wxml wxss 文件。Component 组件 作为一个单独的功能模块，不仅可以包含页面展示还可以包含该模块的事件逻辑处理。 像一个页面一样， Component 组件 可以包含 wxml wxss js json 文件。1. 创建 template 模版不同于 page 和 Component 的创建， 在开发者工具中并不能快速创建一个 template 模版 。所以需要单独创建 wxss wxml 文件。template.wxml 文件语法一个 template.wxml 文件中使用 <template> 标签包含一个模版， 一个 template.wxml 文件可以包含多个 <template> 模版， 使用 name 属性作为模版的名称。在模版中可以接受变量， 使用 {{}} 展示。 为变量的传递者由调用该模版的页面传递。<template name=\"A\">\r\n    <text>template name: {{name}}</text>\r\n</template>\r\n<template name=\"B\">\r\n    <text>template name: {{name}} {{msg}}</text>\r\n</template>\r\n复制代码template.wxss 模版样式文件模版可以拥有自己的样式文件text{\r\n    color: #cccccc;\r\n}\r\n复制代码2. 引用 template 模版template 模版的引用需要使用 <import> 标签。 该标签的 src 属性为需要引用模版的路径。template 模版的使用用 <template> 标签。 使用 is 属性来区别模版文件中定义的模版。使用 data 传入模版中的数据。index.wxml<import src=\"../tpls/template.wxml\" />\r\n\r\n<view>\r\n    <template is=\"A\" data=\"{{name}}\"/>\r\n    <template is=\"B\" data=\"{{name, msg}}\"/>\r\n<view>\r\n复制代码3. 引用模版样式在 调用页面的 wxml 中引用了 template.wxml 后，模版的样式并不会引用， 需要在调用页面的 wxss 中单独引用 template.wxss 文件。index.wxss@import \"./tpls/template.wxss\"\r\n复制代码4. 模版文件中的事件处理在模版中定义的事件, 需要调用页面中执行。 template.wxml<template name=\"A\">\r\n    <text bindtap=\"handleTap\">template name: {{name}}</text>\r\n</template>\r\n复制代码index.jsPage({\r\n    data: {},\r\n    handleTap() {\r\n        console.log('template 模版 click')\r\n    }\r\n})\r\n复制代码5. import 有作用域import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件中 import 的 template，简言之就是 import 不具有递归的特性。例如：C 引用 B，B 引用A，在C中可以使用B定义的 template，在B中可以使用A定义的 template ，但是C不能使用A定义的template6. include 配合 template 模版如同使用 <import src=\"xx/xx/xx.wxml\"> <tempalte is=\"A\" /> 引用和使用模版一样， 同样也可以使用 <include src=\"xx/xx/xx.wxml />\" 来引用一个模版。需要注意的是：使用 <include> 引用模版文件时， 并不能分别出模版文件的模版块， 所以使用 <include>引用的模版文件中只能定义一个模版块。include 可以将目标文件中除了 <template/> <wxs/> 外的整个代码引入，相当于是拷贝到 include 位置。<!-- index.wxml -->\r\n<include src=\"header.wxml\"/>\r\n\r\n<view> body </view>\r\n\r\n<include src=\"footer.wxml\"/>\r\n复制代码<!-- header.wxml -->\r\n<view> header </view>\r\n复制代码<!-- footer.wxml -->\r\n<view> footer </view>\r\n复制代码"}
